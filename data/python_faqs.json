[
    {
        "question": "General Information¶",
        "answer": "Contents General Python FAQ General Information What is Python? What is the Python Software Foundation? Are there copyright restrictions on the use of Python? Why was Python created in the first place? What is Python good for? How does the Python version numbering scheme work? How do I obtain a copy of the Python source? How do I get documentation on Python? I’ve never programmed before. Is there a Python tutorial? Is there a newsgroup or mailing list devoted to Python? How do I get a beta test version of Python? How do I submit bug reports and patches for Python? Are there any published articles about Python that I can reference? Are there any books on Python? Where in the world is www.python.org located? Why is it called Python? Do I have to like “Monty Python’s Flying Circus”? Python in the real world How stable is Python? How many people are using Python? Have any significant projects been done in Python? What new developments are expected for Python in the future? Is it reasonable to propose incompatible changes to Python? Is Python a good language for beginning programmers? Python is an interpreted, interactive, object-oriented programming language.  It\nincorporates modules, exceptions, dynamic typing, very high level dynamic data\ntypes, and classes.  It supports multiple programming paradigms beyond\nobject-oriented programming, such as procedural and functional programming.\nPython combines remarkable power with very clear syntax. It has interfaces to\nmany system calls and libraries, as well as to various window systems, and is\nextensible in C or C++.  It is also usable as an extension language for\napplications that need a programmable interface. Finally, Python is portable:\nit runs on many Unix variants including Linux and macOS, and on Windows. To find out more, start withThe Python Tutorial.  TheBeginner’s Guide to\nPythonlinks to other\nintroductory tutorials and resources for learning Python. The Python Software Foundation is an independent non-profit organization that\nholds the copyright on Python versions 2.1 and newer.  The PSF’s mission is to\nadvance open source technology related to the Python programming language and to\npublicize the use of Python.  The PSF’s home page is athttps://www.python.org/psf/. Donations to the PSF are tax-exempt in the US.  If you use Python and find it\nhelpful, please contribute viathe PSF donation page. You can do anything you want with the source, as long as you leave the\ncopyrights in and display those copyrights in any documentation about Python\nthat you produce.  If you honor the copyright rules, it’s OK to use Python for\ncommercial use, to sell copies of Python in source or binary form (modified or\nunmodified), or to sell products that incorporate Python in some form.  We would\nstill like to know about all commercial use of Python, of course. Seethe license pageto find further\nexplanations and the full text of the PSF License. The Python logo is trademarked, and in certain cases permission is required to\nuse it.  Consultthe Trademark Usage Policyfor more information. Here’s averybrief summary of what started it all, written by Guido van\nRossum: I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython).I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features.I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature.It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible.During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements.In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile. I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython). I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features. I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature. It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible. During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements. In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile. Python is a high-level general-purpose programming language that can be applied\nto many different classes of problems. The language comes with a large standard library that covers areas such as\nstring processing (regular expressions, Unicode, calculating differences between\nfiles), internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP),\nsoftware engineering (unit testing, logging, profiling, parsing\nPython code), and operating system interfaces (system calls, filesystems, TCP/IP\nsockets).  Look at the table of contents forThe Python Standard Libraryto get an idea\nof what’s available.  A wide variety of third-party extensions are also\navailable.  Consultthe Python Package Indexto\nfind packages of interest to you. Python versions are numbered “A.B.C” or “A.B”: Ais the major version number – it is only incremented for really major\nchanges in the language. Bis the minor version number – it is incremented for less earth-shattering\nchanges. Cis the micro version number – it is incremented for each bugfix release. Not all releases are bugfix releases.  In the run-up to a new feature release, a\nseries of development releases are made, denoted as alpha, beta, or release\ncandidate.  Alphas are early releases in which interfaces aren’t yet finalized;\nit’s not unexpected to see an interface change between two alpha releases.\nBetas are more stable, preserving existing interfaces but possibly adding new\nmodules, and release candidates are frozen, making no changes except as needed\nto fix critical bugs. Alpha, beta and release candidate versions have an additional suffix: The suffix for an alpha version is “aN” for some small numberN. The suffix for a beta version is “bN” for some small numberN. The suffix for a release candidate version is “rcN” for some small numberN. In other words, all versions labeled2.0aNprecede the versions labeled2.0bN, which precede versions labeled2.0rcN, andthoseprecede 2.0. You may also find version numbers with a “+” suffix, e.g. “2.2+”.  These are\nunreleased versions, built directly from the CPython development repository.  In\npractice, after a final minor release is made, the version is incremented to the\nnext minor version, which becomes the “a0” version, e.g. “2.4a0”. See theDeveloper’s Guidefor more information about the development cycle, andPEP 387to learn more about Python’s backward compatibility policy.  See also\nthe documentation forsys.version,sys.hexversion, andsys.version_info. The latest Python source distribution is always available from python.org, athttps://www.python.org/downloads/.  The latest development sources can be obtained\nathttps://github.com/python/cpython/. The source distribution is a gzipped tar file containing the complete C source,\nSphinx-formatted documentation, Python library modules, example programs, and\nseveral useful pieces of freely distributable software.  The source will compile\nand run out of the box on most UNIX platforms. Consult theGetting Started section of the Python Developer’s Guidefor more\ninformation on getting the source code and compiling it. The standard documentation for the current stable version of Python is available\nathttps://docs.python.org/3/.  PDF, plain text, and downloadable HTML versions are\nalso available athttps://docs.python.org/3/download.html. The documentation is written in reStructuredText and processed bythe Sphinx\ndocumentation tool.  The reStructuredText source for\nthe documentation is part of the Python source distribution. There are numerous tutorials and books available.  The standard documentation\nincludesThe Python Tutorial. Consultthe Beginner’s Guideto\nfind information for beginning Python programmers, including lists of tutorials. There is a newsgroup,comp.lang.python, and a mailing list,python-list.  The\nnewsgroup and mailing list are gatewayed into each other – if you can read news\nit’s unnecessary to subscribe to the mailing list.comp.lang.pythonis high-traffic, receiving hundreds of postings\nevery day, and Usenet readers are often more able to cope with this volume. Announcements of new software releases and events can be found in\ncomp.lang.python.announce, a low-traffic moderated list that receives about five\npostings per day.  It’s available asthe python-announce mailing list. More info about other mailing lists and newsgroups\ncan be found athttps://www.python.org/community/lists/. Alpha and beta releases are available fromhttps://www.python.org/downloads/.  All\nreleases are announced on the comp.lang.python and comp.lang.python.announce\nnewsgroups and on the Python home page athttps://www.python.org/; an RSS feed of\nnews is available. You can also access the development version of Python through Git.  SeeThe Python Developer’s Guidefor details. To report a bug or submit a patch, use the issue tracker athttps://github.com/python/cpython/issues. For more information on how Python is developed, consultthe Python Developer’s\nGuide. It’s probably best to cite your favorite book about Python. Thevery first articleabout Python was\nwritten in 1991 and is now quite outdated. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303. Yes, there are many, and more are being published.  See the python.org wiki athttps://wiki.python.org/moin/PythonBooksfor a list. You can also search online bookstores for “Python” and filter out the Monty\nPython references; or perhaps search for “Python” and “language”. The Python project’s infrastructure is located all over the world and is managed\nby the Python Infrastructure Team. Detailshere. When he began implementing Python, Guido van Rossum was also reading the\npublished scripts from“Monty Python’s Flying Circus”, a BBC comedy series from the 1970s.  Van Rossum\nthought he needed a name that was short, unique, and slightly mysterious, so he\ndecided to call the language Python. No, but it helps.  :) Very stable.  New, stable releases have been coming out roughly every 6 to 18\nmonths since 1991, and this seems likely to continue.  As of version 3.9,\nPython will have a new feature release every 12 months (PEP 602). The developers issue bugfix releases of older versions, so the stability of\nexisting releases gradually improves.  Bugfix releases, indicated by a third\ncomponent of the version number (e.g. 3.5.3, 3.6.2), are managed for stability;\nonly fixes for known problems are included in a bugfix release, and it’s\nguaranteed that interfaces will remain the same throughout a series of bugfix\nreleases. The latest stable releases can always be found on thePython download page.  There are two production-ready versions\nof Python: 2.x and 3.x. The recommended version is 3.x, which is supported by\nmost widely used libraries.  Although 2.x is still widely used,it is not\nmaintained anymore. There are probably millions of users, though it’s difficult to obtain an exact\ncount. Python is available for free download, so there are no sales figures, and it’s\navailable from many different sites and packaged with many Linux distributions,\nso download statistics don’t tell the whole story either. The comp.lang.python newsgroup is very active, but not all Python users post to\nthe group or even read it. Seehttps://www.python.org/about/successfor a list of projects that use Python.\nConsulting the proceedings forpast Python conferenceswill reveal contributions from many\ndifferent companies and organizations. High-profile Python projects includethe Mailman mailing list managerandthe Zope application server.  Several Linux distributions, most notablyRed Hat, have written part or all of their installer and\nsystem administration software in Python.  Companies that use Python internally\ninclude Google, Yahoo, and Lucasfilm Ltd. Seehttps://peps.python.org/for the Python Enhancement Proposals\n(PEPs). PEPs are design documents describing a suggested new feature for Python,\nproviding a concise technical specification and a rationale.  Look for a PEP\ntitled “Python X.Y Release Schedule”, where X.Y is a version that hasn’t been\npublicly released yet. New development is discussed onthe python-dev mailing list. In general, no.  There are already millions of lines of Python code around the\nworld, so any change in the language that invalidates more than a very small\nfraction of existing programs has to be frowned upon.  Even if you can provide a\nconversion program, there’s still the problem of updating all documentation;\nmany books have been written about Python, and we don’t want to invalidate them\nall at a single stroke. Providing a gradual upgrade path is necessary if a feature has to be changed.PEP 5describes the procedure followed for introducing backward-incompatible\nchanges while minimizing disruption for users. Yes. It is still common to start students with a procedural and statically typed\nlanguage such as Pascal, C, or a subset of C++ or Java.  Students may be better\nserved by learning Python as their first language.  Python has a very simple and\nconsistent syntax and a large standard library and, most importantly, using\nPython in a beginning programming course lets students concentrate on important\nprogramming skills such as problem decomposition and data type design.  With\nPython, students can be quickly introduced to basic concepts such as loops and\nprocedures.  They can probably even work with user-defined objects in their very\nfirst course. For a student who has never programmed before, using a statically typed language\nseems unnatural.  It presents additional complexity that the student must master\nand slows the pace of the course.  The students are trying to learn to think\nlike a computer, decompose problems, design consistent interfaces, and\nencapsulate data.  While learning to use a statically typed language is\nimportant in the long term, it is not necessarily the best topic to address in\nthe students’ first programming course. Many other aspects of Python make it a good first language.  Like Java, Python\nhas a large standard library so that students can be assigned programming\nprojects very early in the course thatdosomething.  Assignments aren’t\nrestricted to the standard four-function calculator and check balancing\nprograms.  By using the standard library, students can gain the satisfaction of\nworking on realistic applications as they learn the fundamentals of programming.\nUsing the standard library also teaches students about code reuse.  Third-party\nmodules such as PyGame are also helpful in extending the students’ reach. Python’s interactive interpreter enables students to test language features\nwhile they’re programming.  They can keep a window with the interpreter running\nwhile they enter their program’s source in another window.  If they can’t\nremember the methods for a list, they can do something like this: With the interpreter, documentation is never far from the student as they are\nprogramming. There are also good IDEs for Python.  IDLE is a cross-platform IDE for Python\nthat is written in Python using Tkinter.\nEmacs users will be happy to know that there is a very good Python mode for\nEmacs.  All of these programming environments provide syntax highlighting,\nauto-indenting, and access to the interactive interpreter while coding.  Consultthe Python wikifor a full list\nof Python editing environments. If you want to discuss Python’s use in education, you may be interested in\njoiningthe edu-sig mailing list.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "General Information¶",
        "answer": "Python is an interpreted, interactive, object-oriented programming language.  It\nincorporates modules, exceptions, dynamic typing, very high level dynamic data\ntypes, and classes.  It supports multiple programming paradigms beyond\nobject-oriented programming, such as procedural and functional programming.\nPython combines remarkable power with very clear syntax. It has interfaces to\nmany system calls and libraries, as well as to various window systems, and is\nextensible in C or C++.  It is also usable as an extension language for\napplications that need a programmable interface. Finally, Python is portable:\nit runs on many Unix variants including Linux and macOS, and on Windows. To find out more, start withThe Python Tutorial.  TheBeginner’s Guide to\nPythonlinks to other\nintroductory tutorials and resources for learning Python. The Python Software Foundation is an independent non-profit organization that\nholds the copyright on Python versions 2.1 and newer.  The PSF’s mission is to\nadvance open source technology related to the Python programming language and to\npublicize the use of Python.  The PSF’s home page is athttps://www.python.org/psf/. Donations to the PSF are tax-exempt in the US.  If you use Python and find it\nhelpful, please contribute viathe PSF donation page. You can do anything you want with the source, as long as you leave the\ncopyrights in and display those copyrights in any documentation about Python\nthat you produce.  If you honor the copyright rules, it’s OK to use Python for\ncommercial use, to sell copies of Python in source or binary form (modified or\nunmodified), or to sell products that incorporate Python in some form.  We would\nstill like to know about all commercial use of Python, of course. Seethe license pageto find further\nexplanations and the full text of the PSF License. The Python logo is trademarked, and in certain cases permission is required to\nuse it.  Consultthe Trademark Usage Policyfor more information. Here’s averybrief summary of what started it all, written by Guido van\nRossum: I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython).I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features.I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature.It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible.During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements.In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile. I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython). I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features. I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature. It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible. During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements. In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile. Python is a high-level general-purpose programming language that can be applied\nto many different classes of problems. The language comes with a large standard library that covers areas such as\nstring processing (regular expressions, Unicode, calculating differences between\nfiles), internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP),\nsoftware engineering (unit testing, logging, profiling, parsing\nPython code), and operating system interfaces (system calls, filesystems, TCP/IP\nsockets).  Look at the table of contents forThe Python Standard Libraryto get an idea\nof what’s available.  A wide variety of third-party extensions are also\navailable.  Consultthe Python Package Indexto\nfind packages of interest to you. Python versions are numbered “A.B.C” or “A.B”: Ais the major version number – it is only incremented for really major\nchanges in the language. Bis the minor version number – it is incremented for less earth-shattering\nchanges. Cis the micro version number – it is incremented for each bugfix release. Not all releases are bugfix releases.  In the run-up to a new feature release, a\nseries of development releases are made, denoted as alpha, beta, or release\ncandidate.  Alphas are early releases in which interfaces aren’t yet finalized;\nit’s not unexpected to see an interface change between two alpha releases.\nBetas are more stable, preserving existing interfaces but possibly adding new\nmodules, and release candidates are frozen, making no changes except as needed\nto fix critical bugs. Alpha, beta and release candidate versions have an additional suffix: The suffix for an alpha version is “aN” for some small numberN. The suffix for a beta version is “bN” for some small numberN. The suffix for a release candidate version is “rcN” for some small numberN. In other words, all versions labeled2.0aNprecede the versions labeled2.0bN, which precede versions labeled2.0rcN, andthoseprecede 2.0. You may also find version numbers with a “+” suffix, e.g. “2.2+”.  These are\nunreleased versions, built directly from the CPython development repository.  In\npractice, after a final minor release is made, the version is incremented to the\nnext minor version, which becomes the “a0” version, e.g. “2.4a0”. See theDeveloper’s Guidefor more information about the development cycle, andPEP 387to learn more about Python’s backward compatibility policy.  See also\nthe documentation forsys.version,sys.hexversion, andsys.version_info. The latest Python source distribution is always available from python.org, athttps://www.python.org/downloads/.  The latest development sources can be obtained\nathttps://github.com/python/cpython/. The source distribution is a gzipped tar file containing the complete C source,\nSphinx-formatted documentation, Python library modules, example programs, and\nseveral useful pieces of freely distributable software.  The source will compile\nand run out of the box on most UNIX platforms. Consult theGetting Started section of the Python Developer’s Guidefor more\ninformation on getting the source code and compiling it. The standard documentation for the current stable version of Python is available\nathttps://docs.python.org/3/.  PDF, plain text, and downloadable HTML versions are\nalso available athttps://docs.python.org/3/download.html. The documentation is written in reStructuredText and processed bythe Sphinx\ndocumentation tool.  The reStructuredText source for\nthe documentation is part of the Python source distribution. There are numerous tutorials and books available.  The standard documentation\nincludesThe Python Tutorial. Consultthe Beginner’s Guideto\nfind information for beginning Python programmers, including lists of tutorials. There is a newsgroup,comp.lang.python, and a mailing list,python-list.  The\nnewsgroup and mailing list are gatewayed into each other – if you can read news\nit’s unnecessary to subscribe to the mailing list.comp.lang.pythonis high-traffic, receiving hundreds of postings\nevery day, and Usenet readers are often more able to cope with this volume. Announcements of new software releases and events can be found in\ncomp.lang.python.announce, a low-traffic moderated list that receives about five\npostings per day.  It’s available asthe python-announce mailing list. More info about other mailing lists and newsgroups\ncan be found athttps://www.python.org/community/lists/. Alpha and beta releases are available fromhttps://www.python.org/downloads/.  All\nreleases are announced on the comp.lang.python and comp.lang.python.announce\nnewsgroups and on the Python home page athttps://www.python.org/; an RSS feed of\nnews is available. You can also access the development version of Python through Git.  SeeThe Python Developer’s Guidefor details. To report a bug or submit a patch, use the issue tracker athttps://github.com/python/cpython/issues. For more information on how Python is developed, consultthe Python Developer’s\nGuide. It’s probably best to cite your favorite book about Python. Thevery first articleabout Python was\nwritten in 1991 and is now quite outdated. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303. Yes, there are many, and more are being published.  See the python.org wiki athttps://wiki.python.org/moin/PythonBooksfor a list. You can also search online bookstores for “Python” and filter out the Monty\nPython references; or perhaps search for “Python” and “language”. The Python project’s infrastructure is located all over the world and is managed\nby the Python Infrastructure Team. Detailshere. When he began implementing Python, Guido van Rossum was also reading the\npublished scripts from“Monty Python’s Flying Circus”, a BBC comedy series from the 1970s.  Van Rossum\nthought he needed a name that was short, unique, and slightly mysterious, so he\ndecided to call the language Python. No, but it helps.  :)",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "What is Python?¶",
        "answer": "Python is an interpreted, interactive, object-oriented programming language.  It\nincorporates modules, exceptions, dynamic typing, very high level dynamic data\ntypes, and classes.  It supports multiple programming paradigms beyond\nobject-oriented programming, such as procedural and functional programming.\nPython combines remarkable power with very clear syntax. It has interfaces to\nmany system calls and libraries, as well as to various window systems, and is\nextensible in C or C++.  It is also usable as an extension language for\napplications that need a programmable interface. Finally, Python is portable:\nit runs on many Unix variants including Linux and macOS, and on Windows. To find out more, start withThe Python Tutorial.  TheBeginner’s Guide to\nPythonlinks to other\nintroductory tutorials and resources for learning Python.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "What is the Python Software Foundation?¶",
        "answer": "The Python Software Foundation is an independent non-profit organization that\nholds the copyright on Python versions 2.1 and newer.  The PSF’s mission is to\nadvance open source technology related to the Python programming language and to\npublicize the use of Python.  The PSF’s home page is athttps://www.python.org/psf/. Donations to the PSF are tax-exempt in the US.  If you use Python and find it\nhelpful, please contribute viathe PSF donation page.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Are there copyright restrictions on the use of Python?¶",
        "answer": "You can do anything you want with the source, as long as you leave the\ncopyrights in and display those copyrights in any documentation about Python\nthat you produce.  If you honor the copyright rules, it’s OK to use Python for\ncommercial use, to sell copies of Python in source or binary form (modified or\nunmodified), or to sell products that incorporate Python in some form.  We would\nstill like to know about all commercial use of Python, of course. Seethe license pageto find further\nexplanations and the full text of the PSF License. The Python logo is trademarked, and in certain cases permission is required to\nuse it.  Consultthe Trademark Usage Policyfor more information.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Why was Python created in the first place?¶",
        "answer": "Here’s averybrief summary of what started it all, written by Guido van\nRossum: I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython).I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features.I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature.It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible.During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements.In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile. I had extensive experience with implementing an interpreted language in the\nABC group at CWI, and from working with this group I had learned a lot about\nlanguage design.  This is the origin of many Python features, including the\nuse of indentation for statement grouping and the inclusion of\nvery-high-level data types (although the details are all different in\nPython). I had a number of gripes about the ABC language, but also liked many of its\nfeatures.  It was impossible to extend the ABC language (or its\nimplementation) to remedy my complaints – in fact its lack of extensibility\nwas one of its biggest problems.  I had some experience with using Modula-2+\nand talked with the designers of Modula-3 and read the Modula-3 report.\nModula-3 is the origin of the syntax and semantics used for exceptions, and\nsome other Python features. I was working in the Amoeba distributed operating system group at CWI.  We\nneeded a better way to do system administration than by writing either C\nprograms or Bourne shell scripts, since Amoeba had its own system call\ninterface which wasn’t easily accessible from the Bourne shell.  My\nexperience with error handling in Amoeba made me acutely aware of the\nimportance of exceptions as a programming language feature. It occurred to me that a scripting language with a syntax like ABC but with\naccess to the Amoeba system calls would fill the need.  I realized that it\nwould be foolish to write an Amoeba-specific language, so I decided that I\nneeded a language that was generally extensible. During the 1989 Christmas holidays, I had a lot of time on my hand, so I\ndecided to give it a try.  During the next year, while still mostly working\non it in my own time, Python was used in the Amoeba project with increasing\nsuccess, and the feedback from colleagues made me add many early\nimprovements. In February 1991, after just over a year of development, I decided to post to\nUSENET.  The rest is in theMisc/HISTORYfile.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "What is Python good for?¶",
        "answer": "Python is a high-level general-purpose programming language that can be applied\nto many different classes of problems. The language comes with a large standard library that covers areas such as\nstring processing (regular expressions, Unicode, calculating differences between\nfiles), internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP),\nsoftware engineering (unit testing, logging, profiling, parsing\nPython code), and operating system interfaces (system calls, filesystems, TCP/IP\nsockets).  Look at the table of contents forThe Python Standard Libraryto get an idea\nof what’s available.  A wide variety of third-party extensions are also\navailable.  Consultthe Python Package Indexto\nfind packages of interest to you.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How does the Python version numbering scheme work?¶",
        "answer": "Python versions are numbered “A.B.C” or “A.B”: Ais the major version number – it is only incremented for really major\nchanges in the language. Bis the minor version number – it is incremented for less earth-shattering\nchanges. Cis the micro version number – it is incremented for each bugfix release. Not all releases are bugfix releases.  In the run-up to a new feature release, a\nseries of development releases are made, denoted as alpha, beta, or release\ncandidate.  Alphas are early releases in which interfaces aren’t yet finalized;\nit’s not unexpected to see an interface change between two alpha releases.\nBetas are more stable, preserving existing interfaces but possibly adding new\nmodules, and release candidates are frozen, making no changes except as needed\nto fix critical bugs. Alpha, beta and release candidate versions have an additional suffix: The suffix for an alpha version is “aN” for some small numberN. The suffix for a beta version is “bN” for some small numberN. The suffix for a release candidate version is “rcN” for some small numberN. In other words, all versions labeled2.0aNprecede the versions labeled2.0bN, which precede versions labeled2.0rcN, andthoseprecede 2.0. You may also find version numbers with a “+” suffix, e.g. “2.2+”.  These are\nunreleased versions, built directly from the CPython development repository.  In\npractice, after a final minor release is made, the version is incremented to the\nnext minor version, which becomes the “a0” version, e.g. “2.4a0”. See theDeveloper’s Guidefor more information about the development cycle, andPEP 387to learn more about Python’s backward compatibility policy.  See also\nthe documentation forsys.version,sys.hexversion, andsys.version_info.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How do I obtain a copy of the Python source?¶",
        "answer": "The latest Python source distribution is always available from python.org, athttps://www.python.org/downloads/.  The latest development sources can be obtained\nathttps://github.com/python/cpython/. The source distribution is a gzipped tar file containing the complete C source,\nSphinx-formatted documentation, Python library modules, example programs, and\nseveral useful pieces of freely distributable software.  The source will compile\nand run out of the box on most UNIX platforms. Consult theGetting Started section of the Python Developer’s Guidefor more\ninformation on getting the source code and compiling it.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How do I get documentation on Python?¶",
        "answer": "The standard documentation for the current stable version of Python is available\nathttps://docs.python.org/3/.  PDF, plain text, and downloadable HTML versions are\nalso available athttps://docs.python.org/3/download.html. The documentation is written in reStructuredText and processed bythe Sphinx\ndocumentation tool.  The reStructuredText source for\nthe documentation is part of the Python source distribution.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "I’ve never programmed before. Is there a Python tutorial?¶",
        "answer": "There are numerous tutorials and books available.  The standard documentation\nincludesThe Python Tutorial. Consultthe Beginner’s Guideto\nfind information for beginning Python programmers, including lists of tutorials.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Is there a newsgroup or mailing list devoted to Python?¶",
        "answer": "There is a newsgroup,comp.lang.python, and a mailing list,python-list.  The\nnewsgroup and mailing list are gatewayed into each other – if you can read news\nit’s unnecessary to subscribe to the mailing list.comp.lang.pythonis high-traffic, receiving hundreds of postings\nevery day, and Usenet readers are often more able to cope with this volume. Announcements of new software releases and events can be found in\ncomp.lang.python.announce, a low-traffic moderated list that receives about five\npostings per day.  It’s available asthe python-announce mailing list. More info about other mailing lists and newsgroups\ncan be found athttps://www.python.org/community/lists/.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How do I get a beta test version of Python?¶",
        "answer": "Alpha and beta releases are available fromhttps://www.python.org/downloads/.  All\nreleases are announced on the comp.lang.python and comp.lang.python.announce\nnewsgroups and on the Python home page athttps://www.python.org/; an RSS feed of\nnews is available. You can also access the development version of Python through Git.  SeeThe Python Developer’s Guidefor details.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How do I submit bug reports and patches for Python?¶",
        "answer": "To report a bug or submit a patch, use the issue tracker athttps://github.com/python/cpython/issues. For more information on how Python is developed, consultthe Python Developer’s\nGuide.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Are there any published articles about Python that I can reference?¶",
        "answer": "It’s probably best to cite your favorite book about Python. Thevery first articleabout Python was\nwritten in 1991 and is now quite outdated. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303. Guido van Rossum and Jelke de Boer, “Interactively Testing Remote Servers\nUsing the Python Programming Language”, CWI Quarterly, Volume 4, Issue 4\n(December 1991), Amsterdam, pp 283–303.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Are there any books on Python?¶",
        "answer": "Yes, there are many, and more are being published.  See the python.org wiki athttps://wiki.python.org/moin/PythonBooksfor a list. You can also search online bookstores for “Python” and filter out the Monty\nPython references; or perhaps search for “Python” and “language”.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Where in the world is www.python.org located?¶",
        "answer": "The Python project’s infrastructure is located all over the world and is managed\nby the Python Infrastructure Team. Detailshere.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Why is it called Python?¶",
        "answer": "When he began implementing Python, Guido van Rossum was also reading the\npublished scripts from“Monty Python’s Flying Circus”, a BBC comedy series from the 1970s.  Van Rossum\nthought he needed a name that was short, unique, and slightly mysterious, so he\ndecided to call the language Python.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Do I have to like “Monty Python’s Flying Circus”?¶",
        "answer": "No, but it helps.  :)",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Python in the real world¶",
        "answer": "Very stable.  New, stable releases have been coming out roughly every 6 to 18\nmonths since 1991, and this seems likely to continue.  As of version 3.9,\nPython will have a new feature release every 12 months (PEP 602). The developers issue bugfix releases of older versions, so the stability of\nexisting releases gradually improves.  Bugfix releases, indicated by a third\ncomponent of the version number (e.g. 3.5.3, 3.6.2), are managed for stability;\nonly fixes for known problems are included in a bugfix release, and it’s\nguaranteed that interfaces will remain the same throughout a series of bugfix\nreleases. The latest stable releases can always be found on thePython download page.  There are two production-ready versions\nof Python: 2.x and 3.x. The recommended version is 3.x, which is supported by\nmost widely used libraries.  Although 2.x is still widely used,it is not\nmaintained anymore. There are probably millions of users, though it’s difficult to obtain an exact\ncount. Python is available for free download, so there are no sales figures, and it’s\navailable from many different sites and packaged with many Linux distributions,\nso download statistics don’t tell the whole story either. The comp.lang.python newsgroup is very active, but not all Python users post to\nthe group or even read it. Seehttps://www.python.org/about/successfor a list of projects that use Python.\nConsulting the proceedings forpast Python conferenceswill reveal contributions from many\ndifferent companies and organizations. High-profile Python projects includethe Mailman mailing list managerandthe Zope application server.  Several Linux distributions, most notablyRed Hat, have written part or all of their installer and\nsystem administration software in Python.  Companies that use Python internally\ninclude Google, Yahoo, and Lucasfilm Ltd. Seehttps://peps.python.org/for the Python Enhancement Proposals\n(PEPs). PEPs are design documents describing a suggested new feature for Python,\nproviding a concise technical specification and a rationale.  Look for a PEP\ntitled “Python X.Y Release Schedule”, where X.Y is a version that hasn’t been\npublicly released yet. New development is discussed onthe python-dev mailing list. In general, no.  There are already millions of lines of Python code around the\nworld, so any change in the language that invalidates more than a very small\nfraction of existing programs has to be frowned upon.  Even if you can provide a\nconversion program, there’s still the problem of updating all documentation;\nmany books have been written about Python, and we don’t want to invalidate them\nall at a single stroke. Providing a gradual upgrade path is necessary if a feature has to be changed.PEP 5describes the procedure followed for introducing backward-incompatible\nchanges while minimizing disruption for users. Yes. It is still common to start students with a procedural and statically typed\nlanguage such as Pascal, C, or a subset of C++ or Java.  Students may be better\nserved by learning Python as their first language.  Python has a very simple and\nconsistent syntax and a large standard library and, most importantly, using\nPython in a beginning programming course lets students concentrate on important\nprogramming skills such as problem decomposition and data type design.  With\nPython, students can be quickly introduced to basic concepts such as loops and\nprocedures.  They can probably even work with user-defined objects in their very\nfirst course. For a student who has never programmed before, using a statically typed language\nseems unnatural.  It presents additional complexity that the student must master\nand slows the pace of the course.  The students are trying to learn to think\nlike a computer, decompose problems, design consistent interfaces, and\nencapsulate data.  While learning to use a statically typed language is\nimportant in the long term, it is not necessarily the best topic to address in\nthe students’ first programming course. Many other aspects of Python make it a good first language.  Like Java, Python\nhas a large standard library so that students can be assigned programming\nprojects very early in the course thatdosomething.  Assignments aren’t\nrestricted to the standard four-function calculator and check balancing\nprograms.  By using the standard library, students can gain the satisfaction of\nworking on realistic applications as they learn the fundamentals of programming.\nUsing the standard library also teaches students about code reuse.  Third-party\nmodules such as PyGame are also helpful in extending the students’ reach. Python’s interactive interpreter enables students to test language features\nwhile they’re programming.  They can keep a window with the interpreter running\nwhile they enter their program’s source in another window.  If they can’t\nremember the methods for a list, they can do something like this: With the interpreter, documentation is never far from the student as they are\nprogramming. There are also good IDEs for Python.  IDLE is a cross-platform IDE for Python\nthat is written in Python using Tkinter.\nEmacs users will be happy to know that there is a very good Python mode for\nEmacs.  All of these programming environments provide syntax highlighting,\nauto-indenting, and access to the interactive interpreter while coding.  Consultthe Python wikifor a full list\nof Python editing environments. If you want to discuss Python’s use in education, you may be interested in\njoiningthe edu-sig mailing list.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How stable is Python?¶",
        "answer": "Very stable.  New, stable releases have been coming out roughly every 6 to 18\nmonths since 1991, and this seems likely to continue.  As of version 3.9,\nPython will have a new feature release every 12 months (PEP 602). The developers issue bugfix releases of older versions, so the stability of\nexisting releases gradually improves.  Bugfix releases, indicated by a third\ncomponent of the version number (e.g. 3.5.3, 3.6.2), are managed for stability;\nonly fixes for known problems are included in a bugfix release, and it’s\nguaranteed that interfaces will remain the same throughout a series of bugfix\nreleases. The latest stable releases can always be found on thePython download page.  There are two production-ready versions\nof Python: 2.x and 3.x. The recommended version is 3.x, which is supported by\nmost widely used libraries.  Although 2.x is still widely used,it is not\nmaintained anymore.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "How many people are using Python?¶",
        "answer": "There are probably millions of users, though it’s difficult to obtain an exact\ncount. Python is available for free download, so there are no sales figures, and it’s\navailable from many different sites and packaged with many Linux distributions,\nso download statistics don’t tell the whole story either. The comp.lang.python newsgroup is very active, but not all Python users post to\nthe group or even read it.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Have any significant projects been done in Python?¶",
        "answer": "Seehttps://www.python.org/about/successfor a list of projects that use Python.\nConsulting the proceedings forpast Python conferenceswill reveal contributions from many\ndifferent companies and organizations. High-profile Python projects includethe Mailman mailing list managerandthe Zope application server.  Several Linux distributions, most notablyRed Hat, have written part or all of their installer and\nsystem administration software in Python.  Companies that use Python internally\ninclude Google, Yahoo, and Lucasfilm Ltd.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "What new developments are expected for Python in the future?¶",
        "answer": "Seehttps://peps.python.org/for the Python Enhancement Proposals\n(PEPs). PEPs are design documents describing a suggested new feature for Python,\nproviding a concise technical specification and a rationale.  Look for a PEP\ntitled “Python X.Y Release Schedule”, where X.Y is a version that hasn’t been\npublicly released yet. New development is discussed onthe python-dev mailing list.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Is it reasonable to propose incompatible changes to Python?¶",
        "answer": "In general, no.  There are already millions of lines of Python code around the\nworld, so any change in the language that invalidates more than a very small\nfraction of existing programs has to be frowned upon.  Even if you can provide a\nconversion program, there’s still the problem of updating all documentation;\nmany books have been written about Python, and we don’t want to invalidate them\nall at a single stroke. Providing a gradual upgrade path is necessary if a feature has to be changed.PEP 5describes the procedure followed for introducing backward-incompatible\nchanges while minimizing disruption for users.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "Is Python a good language for beginning programmers?¶",
        "answer": "Yes. It is still common to start students with a procedural and statically typed\nlanguage such as Pascal, C, or a subset of C++ or Java.  Students may be better\nserved by learning Python as their first language.  Python has a very simple and\nconsistent syntax and a large standard library and, most importantly, using\nPython in a beginning programming course lets students concentrate on important\nprogramming skills such as problem decomposition and data type design.  With\nPython, students can be quickly introduced to basic concepts such as loops and\nprocedures.  They can probably even work with user-defined objects in their very\nfirst course. For a student who has never programmed before, using a statically typed language\nseems unnatural.  It presents additional complexity that the student must master\nand slows the pace of the course.  The students are trying to learn to think\nlike a computer, decompose problems, design consistent interfaces, and\nencapsulate data.  While learning to use a statically typed language is\nimportant in the long term, it is not necessarily the best topic to address in\nthe students’ first programming course. Many other aspects of Python make it a good first language.  Like Java, Python\nhas a large standard library so that students can be assigned programming\nprojects very early in the course thatdosomething.  Assignments aren’t\nrestricted to the standard four-function calculator and check balancing\nprograms.  By using the standard library, students can gain the satisfaction of\nworking on realistic applications as they learn the fundamentals of programming.\nUsing the standard library also teaches students about code reuse.  Third-party\nmodules such as PyGame are also helpful in extending the students’ reach. Python’s interactive interpreter enables students to test language features\nwhile they’re programming.  They can keep a window with the interpreter running\nwhile they enter their program’s source in another window.  If they can’t\nremember the methods for a list, they can do something like this: With the interpreter, documentation is never far from the student as they are\nprogramming. There are also good IDEs for Python.  IDLE is a cross-platform IDE for Python\nthat is written in Python using Tkinter.\nEmacs users will be happy to know that there is a very good Python mode for\nEmacs.  All of these programming environments provide syntax highlighting,\nauto-indenting, and access to the interactive interpreter while coding.  Consultthe Python wikifor a full list\nof Python editing environments. If you want to discuss Python’s use in education, you may be interested in\njoiningthe edu-sig mailing list.",
        "source": "data/html/general-python-faq.html"
    },
    {
        "question": "General Questions¶",
        "answer": "Contents Programming FAQ General Questions Is there a source code level debugger with breakpoints, single-stepping, etc.? Are there tools to help find bugs or perform static analysis? How can I create a stand-alone binary from a Python script? Are there coding standards or a style guide for Python programs? Core Language Why am I getting an UnboundLocalError when the variable has a value? What are the rules for local and global variables in Python? Why do lambdas defined in a loop with different values all return the same result? How do I share global variables across modules? What are the “best practices” for using import in a module? Why are default values shared between objects? How can I pass optional or keyword parameters from one function to another? What is the difference between arguments and parameters? Why did changing list ‘y’ also change list ‘x’? How do I write a function with output parameters (call by reference)? How do you make a higher order function in Python? How do I copy an object in Python? How can I find the methods or attributes of an object? How can my code discover the name of an object? What’s up with the comma operator’s precedence? Is there an equivalent of C’s “?:” ternary operator? Is it possible to write obfuscated one-liners in Python? What does the slash(/) in the parameter list of a function mean? Numbers and strings How do I specify hexadecimal and octal integers? Why does -22 // 10 return -3? How do I get int literal attribute instead of SyntaxError? How do I convert a string to a number? How do I convert a number to a string? How do I modify a string in place? How do I use strings to call functions/methods? Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings? Is there a scanf() or sscanf() equivalent? What does ‘UnicodeDecodeError’ or ‘UnicodeEncodeError’ error  mean? Can I end a raw string with an odd number of backslashes? Performance My program is too slow. How do I speed it up? What is the most efficient way to concatenate many strings together? Sequences (Tuples/Lists) How do I convert between tuples and lists? What’s a negative index? How do I iterate over a sequence in reverse order? How do you remove duplicates from a list? How do you remove multiple items from a list How do you make an array in Python? How do I create a multidimensional list? How do I apply a method or function to a sequence of objects? Why does a_tuple[i] += [‘item’] raise an exception when the addition works? I want to do a complicated sort: can you do a Schwartzian Transform in Python? How can I sort one list by values from another list? Objects What is a class? What is a method? What is self? How do I check if an object is an instance of a given class or of a subclass of it? What is delegation? How do I call a method defined in a base class from a derived class that extends it? How can I organize my code to make it easier to change the base class? How do I create static class data and static class methods? How can I overload constructors (or methods) in Python? I try to use __spam and I get an error about _SomeClassName__spam. My class defines __del__ but it is not called when I delete the object. How do I get a list of all instances of a given class? Why does the result ofid()appear to be not unique? When can I rely on identity tests with theisoperator? How can a subclass control what data is stored in an immutable instance? How do I cache method calls? Modules How do I create a .pyc file? How do I find the current module name? How can I have modules that mutually import each other? __import__(‘x.y.z’) returns <module ‘x’>; how do I get z? When I edit an imported module and reimport it, the changes don’t show up.  Why does this happen? Yes. Several debuggers for Python are described below, and the built-in functionbreakpoint()allows you to drop into any of them. The pdb module is a simple but adequate console-mode debugger for Python. It is\npart of the standard Python library, and isdocumentedintheLibraryReferenceManual. You can also write your own debugger by using the code\nfor pdb as an example. The IDLE interactive development environment, which is part of the standard\nPython distribution (normally available asTools/scripts/idle3),\nincludes a graphical debugger. PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The\nPythonWin debugger colors breakpoints and has quite a few cool features such as\ndebugging non-PythonWin programs.  PythonWin is available as part ofpywin32project and\nas a part of theActivePythondistribution. Ericis an IDE built on PyQt\nand the Scintilla editing component. trepan3kis a gdb-like debugger. Visual Studio Codeis an IDE with debugging\ntools that integrates with version-control software. There are a number of commercial Python IDEs that include graphical debuggers.\nThey include: Wing IDE Komodo IDE PyCharm Yes. PylintandPyflakesdo basic checking that will\nhelp you catch bugs sooner. Static type checkers such asMypy,Pyre, andPytypecan check type hints in Python\nsource code. You don’t need the ability to compile Python to C code if all you want is a\nstand-alone program that users can download and run without having to install\nthe Python distribution first.  There are a number of tools that determine the\nset of modules required by a program and bind these modules together with a\nPython binary to produce a single executable. One is to use the freeze tool, which is included in the Python source tree asTools/freeze.\nIt converts Python byte code to C arrays; with a C compiler you can\nembed all your modules into a new program, which is then linked with the\nstandard Python modules. It works by scanning your source recursively for import statements (in both\nforms) and looking for the modules in the standard Python path as well as in the\nsource directory (for built-in modules).  It then turns the bytecode for modules\nwritten in Python into C code (array initializers that can be turned into code\nobjects using the marshal module) and creates a custom-made config file that\nonly contains those built-in modules which are actually used in the program.  It\nthen compiles the generated C code and links it with the rest of the Python\ninterpreter to form a self-contained binary which acts exactly like your script. The following packages can help with the creation of console and GUI\nexecutables: Nuitka(Cross-platform) PyInstaller(Cross-platform) PyOxidizer(Cross-platform) cx_Freeze(Cross-platform) py2app(macOS only) py2exe(Windows only) Yes.  The coding style required for standard library modules is documented asPEP 8. It can be a surprise to get theUnboundLocalErrorin previously working\ncode when it is modified by adding an assignment statement somewhere in\nthe body of a function. This code: works, but this code: results in anUnboundLocalError: This is because when you make an assignment to a variable in a scope, that\nvariable becomes local to that scope and shadows any similarly named variable\nin the outer scope.  Since the last statement in foo assigns a new value tox, the compiler recognizes it as a local variable.  Consequently when the\nearlierprint(x)attempts to print the uninitialized local variable and\nan error results. In the example above you can access the outer scope variable by declaring it\nglobal: This explicit declaration is required in order to remind you that (unlike the\nsuperficially analogous situation with class and instance variables) you are\nactually modifying the value of the variable in the outer scope: You can do a similar thing in a nested scope using thenonlocalkeyword: In Python, variables that are only referenced inside a function are implicitly\nglobal.  If a variable is assigned a value anywhere within the function’s body,\nit’s assumed to be a local unless explicitly declared as global. Though a bit surprising at first, a moment’s consideration explains this.  On\none hand, requiringglobalfor assigned variables provides a bar\nagainst unintended side-effects.  On the other hand, ifglobalwas required\nfor all global references, you’d be usingglobalall the time.  You’d have\nto declare as global every reference to a built-in function or to a component of\nan imported module.  This clutter would defeat the usefulness of theglobaldeclaration for identifying side-effects. Assume you use a for loop to define a few different lambdas (or even plain\nfunctions), e.g.: This gives you a list that contains 5 lambdas that calculatex**2.  You\nmight expect that, when called, they would return, respectively,0,1,4,9, and16.  However, when you actually try you will see that\nthey all return16: This happens becausexis not local to the lambdas, but is defined in\nthe outer scope, and it is accessed when the lambda is called — not when it\nis defined.  At the end of the loop, the value ofxis4, so all the\nfunctions now return4**2, i.e.16.  You can also verify this by\nchanging the value ofxand see how the results of the lambdas change: In order to avoid this, you need to save the values in variables local to the\nlambdas, so that they don’t rely on the value of the globalx: Here,n=xcreates a new variablenlocal to the lambda and computed\nwhen the lambda is defined so that it has the same value thatxhad at\nthat point in the loop.  This means that the value ofnwill be0in the first lambda,1in the second,2in the third, and so on.\nTherefore each lambda will now return the correct result: Note that this behaviour is not peculiar to lambdas, but applies to regular\nfunctions too. The canonical way to share information across modules within a single program is\nto create a special module (often called config or cfg).  Just import the config\nmodule in all modules of your application; the module then becomes available as\na global name.  Because there is only one instance of each module, any changes\nmade to the module object get reflected everywhere.  For example: config.py: mod.py: main.py: Note that using a module is also the basis for implementing the singleton design\npattern, for the same reason. In general, don’t usefrommodulenameimport*.  Doing so clutters the\nimporter’s namespace, and makes it much harder for linters to detect undefined\nnames. Import modules at the top of a file.  Doing so makes it clear what other modules\nyour code requires and avoids questions of whether the module name is in scope.\nUsing one import per line makes it easy to add and delete module imports, but\nusing multiple imports per line uses less screen space. It’s good practice if you import modules in the following order: standard library modules – e.g.sys,os,argparse,re third-party library modules (anything installed in Python’s site-packages\ndirectory) – e.g.dateutil,requests,PIL.Image locally developed modules It is sometimes necessary to move imports to a function or class to avoid\nproblems with circular imports.  Gordon McMillan says: Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. In this case, if the second module is only used in one function, then the import\ncan easily be moved into that function.  By the time the import is called, the\nfirst module will have finished initializing, and the second module can do its\nimport. It may also be necessary to move imports out of the top level of code if some of\nthe modules are platform-specific.  In that case, it may not even be possible to\nimport all of the modules at the top of the file.  In this case, importing the\ncorrect modules in the corresponding platform-specific code is a good option. Only move imports into a local scope, such as inside a function definition, if\nit’s necessary to solve a problem such as avoiding a circular import or are\ntrying to reduce the initialization time of a module.  This technique is\nespecially helpful if many of the imports are unnecessary depending on how the\nprogram executes.  You may also want to move imports into a function if the\nmodules are only ever used in that function.  Note that loading a module the\nfirst time may be expensive because of the one time initialization of the\nmodule, but loading a module multiple times is virtually free, costing only a\ncouple of dictionary lookups.  Even if the module name has gone out of scope,\nthe module is probably available insys.modules. This type of bug commonly bites neophyte programmers.  Consider this function: The first time you call this function,mydictcontains a single item.  The\nsecond time,mydictcontains two items because whenfoo()begins\nexecuting,mydictstarts out with an item already in it. It is often expected that a function call creates new objects for default\nvalues. This is not what happens. Default values are created exactly once, when\nthe function is defined.  If that object is changed, like the dictionary in this\nexample, subsequent calls to the function will refer to this changed object. By definition, immutable objects such as numbers, strings, tuples, andNone,\nare safe from change. Changes to mutable objects such as dictionaries, lists,\nand class instances can lead to confusion. Because of this feature, it is good programming practice to not use mutable\nobjects as default values.  Instead, useNoneas the default value and\ninside the function, check if the parameter isNoneand create a new\nlist/dictionary/whatever if it is.  For example, don’t write: but: This feature can be useful.  When you have a function that’s time-consuming to\ncompute, a common technique is to cache the parameters and the resulting value\nof each call to the function, and return the cached value if the same value is\nrequested again.  This is called “memoizing”, and can be implemented like this: You could use a global variable containing a dictionary instead of the default\nvalue; it’s a matter of taste. Collect the arguments using the*and**specifiers in the function’s\nparameter list; this gives you the positional arguments as a tuple and the\nkeyword arguments as a dictionary.  You can then pass these arguments when\ncalling another function by using*and**: Parametersare defined by the names that appear in a\nfunction definition, whereasargumentsare the values\nactually passed to a function when calling it.  Parameters define whatkind of argumentsa function can accept.  For\nexample, given the function definition: foo,barandkwargsare parameters offunc.  However, when callingfunc, for example: the values42,314, andsomevarare arguments. If you wrote code like: you might be wondering why appending an element toychangedxtoo. There are two factors that produce this result: Variables are simply names that refer to objects.  Doingy=xdoesn’t\ncreate a copy of the list – it creates a new variableythat refers to\nthe same objectxrefers to.  This means that there is only one object\n(the list), and bothxandyrefer to it. Lists aremutable, which means that you can change their content. After the call toappend(), the content of the mutable object has\nchanged from[]to[10].  Since both the variables refer to the same\nobject, using either name accesses the modified value[10]. If we instead assign an immutable object tox: we can see that in this casexandyare not equal anymore.  This is\nbecause integers areimmutable, and when we dox=x+1we are not\nmutating the int5by incrementing its value; instead, we are creating a\nnew object (the int6) and assigning it tox(that is, changing which\nobjectxrefers to).  After this assignment we have two objects (the ints6and5) and two variables that refer to them (xnow refers to6butystill refers to5). Some operations (for exampley.append(10)andy.sort()) mutate the\nobject, whereas superficially similar operations (for exampley=y+[10]andsorted(y)) create a new object.  In general in Python (and in all cases\nin the standard library) a method that mutates an object will returnNoneto help avoid getting the two types of operations confused.  So if you\nmistakenly writey.sort()thinking it will give you a sorted copy ofy,\nyou’ll instead end up withNone, which will likely cause your program to\ngenerate an easily diagnosed error. However, there is one class of operations where the same operation sometimes\nhas different behaviors with different types:  the augmented assignment\noperators.  For example,+=mutates lists but not tuples or ints (a_list+=[1,2,3]is equivalent toa_list.extend([1,2,3])and mutatesa_list, whereassome_tuple+=(1,2,3)andsome_int+=1create\nnew objects). In other words: If we have a mutable object (list,dict,set,\netc.), we can use some specific operations to mutate it and all the variables\nthat refer to it will see the change. If we have an immutable object (str,int,tuple,\netc.), all the variables that refer to it will always see the same value,\nbut operations that transform that value into a new value always return a new\nobject. If you want to know if two variables refer to the same object or not, you can\nuse theisoperator, or the built-in functionid(). Remember that arguments are passed by assignment in Python.  Since assignment\njust creates references to objects, there’s no alias between an argument name in\nthe caller and callee, and so no call-by-reference per se.  You can achieve the\ndesired effect in a number of ways. By returning a tuple of the results: This is almost always the clearest solution. By using global variables.  This isn’t thread-safe, and is not recommended. By passing a mutable (changeable in-place) object: By passing in a dictionary that gets mutated: Or bundle up values in a class instance: There’s almost never a good reason to get this complicated. Your best choice is to return a tuple containing the multiple results. You have two choices: you can use nested scopes or you can use callable objects.\nFor example, suppose you wanted to definelinear(a,b)which returns a\nfunctionf(x)that computes the valuea*x+b.  Using nested scopes: Or using a callable object: In both cases, gives a callable object wheretaxes(10e6)==0.3*10e6+2. The callable object approach has the disadvantage that it is a bit slower and\nresults in slightly longer code.  However, note that a collection of callables\ncan share their signature via inheritance: Object can encapsulate state for several methods: Hereinc(),dec()andreset()act like functions which share the\nsame counting variable. In general, trycopy.copy()orcopy.deepcopy()for the general case.\nNot all objects can be copied, but most can. Some objects can be copied more easily.  Dictionaries have acopy()method: Sequences can be copied by slicing: For an instancexof a user-defined class,dir(x)returns an alphabetized\nlist of the names containing the instance attributes and methods and attributes\ndefined by its class. Generally speaking, it can’t, because objects don’t really have names.\nEssentially, assignment always binds a name to a value; the same is true ofdefandclassstatements, but in that case the value is a\ncallable. Consider the following code: Arguably the class has a name: even though it is bound to two names and invoked\nthrough the nameBthe created instance is still reported as an instance of\nclassA.  However, it is impossible to say whether the instance’s name isaorb, since both names are bound to the same value. Generally speaking it should not be necessary for your code to “know the names”\nof particular values. Unless you are deliberately writing introspective\nprograms, this is usually an indication that a change of approach might be\nbeneficial. In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to\nthis question: The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)…….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all! The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)… ….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all! Comma is not an operator in Python.  Consider this session: Since the comma is not an operator, but a separator between expressions the\nabove is evaluated as if you had entered: not: The same is true of the various assignment operators (=,+=etc).  They\nare not truly operators but syntactic delimiters in assignment statements. Yes, there is. The syntax is as follows: Before this syntax was introduced in Python 2.5, a common idiom was to use\nlogical operators: However, this idiom is unsafe, as it can give wrong results whenon_truehas a false boolean value.  Therefore, it is always better to use\nthe...if...else...form. Yes.  Usually this is done by nestinglambdawithinlambda.  See the following three examples, slightly adapted from Ulf Bartelt: Don’t try this at home, kids! A slash in the argument list of a function denotes that the parameters prior to\nit are positional-only.  Positional-only parameters are the ones without an\nexternally usable name.  Upon calling a function that accepts positional-only\nparameters, arguments are mapped to parameters based solely on their position.\nFor example,divmod()is a function that accepts positional-only\nparameters. Its documentation looks like this: The slash at the end of the parameter list means that both parameters are\npositional-only. Thus, callingdivmod()with keyword arguments would lead\nto an error: To specify an octal digit, precede the octal value with a zero, and then a lower\nor uppercase “o”.  For example, to set the variable “a” to the octal value “10”\n(8 in decimal), type: Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero,\nand then a lower or uppercase “x”.  Hexadecimal digits can be specified in lower\nor uppercase.  For example, in the Python interpreter: It’s primarily driven by the desire thati%jhave the same sign asj.\nIf you want that, and also want: then integer division has to return the floor.  C also requires that identity to\nhold, and then compilers that truncatei//jneed to makei%jhave\nthe same sign asi. There are few real use cases fori%jwhenjis negative.  Whenjis positive, there are many, and in virtually all of them it’s more useful fori%jto be>=0.  If the clock says 10 now, what did it say 200 hours\nago?-190%12==2is useful;-190%12==-10is a bug waiting to\nbite. Trying to lookup anintliteral attribute in the normal manner gives\naSyntaxErrorbecause the period is seen as a decimal point: The solution is to separate the literal from the period\nwith either a space or parentheses. For integers, use the built-inint()type constructor, e.g.int('144')==144.  Similarly,float()converts to a floating-point number,\ne.g.float('144')==144.0. By default, these interpret the number as decimal, so thatint('0144')==144holds true, andint('0x144')raisesValueError.int(string,base)takes the base to convert from as a second optional argument, soint('0x144',16)==324.  If the base is specified as 0, the number is interpreted\nusing Python’s rules: a leading ‘0o’ indicates octal, and ‘0x’ indicates a hex\nnumber. Do not use the built-in functioneval()if all you need is to convert\nstrings to numbers.eval()will be significantly slower and it presents a\nsecurity risk: someone could pass you a Python expression that might have\nunwanted side effects.  For example, someone could pass__import__('os').system(\"rm-rf$HOME\")which would erase your home\ndirectory. eval()also has the effect of interpreting numbers as Python expressions,\nso that e.g.eval('09')gives a syntax error because Python does not allow\nleading ‘0’ in a decimal number (except ‘0’). To convert, e.g., the number144to the string'144', use the built-in type\nconstructorstr().  If you want a hexadecimal or octal representation, use\nthe built-in functionshex()oroct().  For fancy formatting, see\nthef-stringsandFormat String Syntaxsections,\ne.g.\"{:04d}\".format(144)yields'0144'and\"{:.3f}\".format(1.0/3.0)yields'0.333'. You can’t, because strings are immutable.  In most situations, you should\nsimply construct a new string from the various parts you want to assemble\nit from.  However, if you need an object with the ability to modify in-place\nunicode data, try using anio.StringIOobject or thearraymodule: There are various techniques. The best is to use a dictionary that maps strings to functions.  The primary\nadvantage of this technique is that the strings do not need to match the names\nof the functions.  This is also the primary technique used to emulate a case\nconstruct: Use the built-in functiongetattr(): Note thatgetattr()works on any object, including classes, class\ninstances, modules, and so on. This is used in several places in the standard library, like this: Uselocals()to resolve the function name: You can useS.rstrip(\"\\r\\n\")to remove all occurrences of any line\nterminator from the end of the stringSwithout removing other trailing\nwhitespace.  If the stringSrepresents more than one line, with several\nempty lines at the end, the line terminators for all the blank lines will\nbe removed: Since this is typically only desired when reading text one line at a time, usingS.rstrip()this way works well. Not as such. For simple input parsing, the easiest approach is usually to split the line into\nwhitespace-delimited words using thesplit()method of string objects\nand then convert decimal strings to numeric values usingint()orfloat().split()supports an optional “sep” parameter which is useful\nif the line uses something other than whitespace as a separator. For more complicated input parsing, regular expressions are more powerful\nthan C’ssscanfand better suited for the task. See theUnicode HOWTO. A raw string ending with an odd number of backslashes will escape the string’s quote: There are several workarounds for this. One is to use regular strings and double\nthe backslashes: Another is to concatenate a regular string containing an escaped backslash to the\nraw string: It is also possible to useos.path.join()to append a backslash on Windows: Note that while a backslash will “escape” a quote for the purposes of\ndetermining where the raw string ends, no escaping occurs when interpreting the\nvalue of the raw string. That is, the backslash remains present in the value of\nthe raw string: Also see the specification in thelanguage reference. That’s a tough one, in general.  First, here are a list of things to\nremember before diving further: Performance characteristics vary across Python implementations.  This FAQ\nfocuses onCPython. Behaviour can vary across operating systems, especially when talking about\nI/O or multi-threading. You should always find the hot spots in your programbeforeattempting to\noptimize any code (see theprofilemodule). Writing benchmark scripts will allow you to iterate quickly when searching\nfor improvements (see thetimeitmodule). It is highly recommended to have good code coverage (through unit testing\nor any other technique) before potentially introducing regressions hidden\nin sophisticated optimizations. That being said, there are many tricks to speed up Python code.  Here are\nsome general principles which go a long way towards reaching acceptable\nperformance levels: Making your algorithms faster (or changing to faster ones) can yield\nmuch larger benefits than trying to sprinkle micro-optimization tricks\nall over your code. Use the right data structures.  Study documentation for theBuilt-in Typesand thecollectionsmodule. When the standard library provides a primitive for doing something, it is\nlikely (although not guaranteed) to be faster than any alternative you\nmay come up with.  This is doubly true for primitives written in C, such\nas builtins and some extension types.  For example, be sure to use\neither thelist.sort()built-in method or the relatedsorted()function to do sorting (and see theSorting Techniquesfor examples\nof moderately advanced usage). Abstractions tend to create indirections and force the interpreter to work\nmore.  If the levels of indirection outweigh the amount of useful work\ndone, your program will be slower.  You should avoid excessive abstraction,\nespecially under the form of tiny functions or methods (which are also often\ndetrimental to readability). If you have reached the limit of what pure Python can allow, there are tools\nto take you further away.  For example,Cythoncan\ncompile a slightly modified version of Python code into a C extension, and\ncan be used on many different platforms.  Cython can take advantage of\ncompilation (and optional type annotations) to make your code significantly\nfaster than when interpreted.  If you are confident in your C programming\nskills, you can alsowrite a C extension moduleyourself. See also The wiki page devoted toperformance tips. strandbytesobjects are immutable, therefore concatenating\nmany strings together is inefficient as each concatenation creates a new\nobject.  In the general case, the total runtime cost is quadratic in the\ntotal string length. To accumulate manystrobjects, the recommended idiom is to place\nthem into a list and callstr.join()at the end: (another reasonably efficient idiom is to useio.StringIO) To accumulate manybytesobjects, the recommended idiom is to extend\nabytearrayobject using in-place concatenation (the+=operator): The type constructortuple(seq)converts any sequence (actually, any\niterable) into a tuple with the same items in the same order. For example,tuple([1,2,3])yields(1,2,3)andtuple('abc')yields('a','b','c').  If the argument is a tuple, it does not make a copy\nbut returns the same object, so it is cheap to calltuple()when you\naren’t sure that an object is already a tuple. The type constructorlist(seq)converts any sequence or iterable into a list\nwith the same items in the same order.  For example,list((1,2,3))yields[1,2,3]andlist('abc')yields['a','b','c'].  If the argument\nis a list, it makes a copy just likeseq[:]would. Python sequences are indexed with positive numbers and negative numbers.  For\npositive numbers 0 is the first index 1 is the second index and so forth.  For\nnegative indices -1 is the last index and -2 is the penultimate (next to last)\nindex and so forth.  Think ofseq[-n]as the same asseq[len(seq)-n]. Using negative indices can be very convenient.  For exampleS[:-1]is all of\nthe string except for its last character, which is useful for removing the\ntrailing newline from a string. Use thereversed()built-in function: This won’t touch your original sequence, but build a new copy with reversed\norder to iterate over. See the Python Cookbook for a long discussion of many ways to do this: https://code.activestate.com/recipes/52560/ https://code.activestate.com/recipes/52560/ If you don’t mind reordering the list, sort it and then scan from the end of the\nlist, deleting duplicates as you go: If all elements of the list may be used as set keys (i.e. they are allhashable) this is often faster This converts the list into a set, thereby removing duplicates, and then back\ninto a list. As with removing duplicates, explicitly iterating in reverse with a\ndelete condition is one possibility.  However, it is easier and faster\nto use slice replacement with an implicit or explicit forward iteration.\nHere are three variations.: The list comprehension may be fastest. Use a list: Lists are equivalent to C or Pascal arrays in their time complexity; the primary\ndifference is that a Python list can contain objects of many different types. Thearraymodule also provides methods for creating arrays of fixed types\nwith compact representations, but they are slower to index than lists.  Also\nnote thatNumPyand other third party packages define array-like structures with\nvarious characteristics as well. To get Lisp-style linked lists, you can emulatecons cellsusing tuples: If mutability is desired, you could use lists instead of tuples.  Here the\nanalogue of a Lispcarislisp_list[0]and the analogue ofcdrislisp_list[1].  Only do this if you’re sure you really need to, because it’s\nusually a lot slower than using Python lists. You probably tried to make a multidimensional array like this: This looks correct if you print it: But when you assign a value, it shows up in multiple places: The reason is that replicating a list with*doesn’t create copies, it only\ncreates references to the existing objects.  The*3creates a list\ncontaining 3 references to the same list of length two.  Changes to one row will\nshow in all rows, which is almost certainly not what you want. The suggested approach is to create a list of the desired length first and then\nfill in each element with a newly created list: This generates a list containing 3 different lists of length two.  You can also\nuse a list comprehension: Or, you can use an extension that provides a matrix datatype;NumPyis the best known. To call a method or function and accumulate the return values is a list,\nalist comprehensionis an elegant solution: To just run the method or function without saving the return values,\na plainforloop will suffice: This is because of a combination of the fact that augmented assignment\noperators areassignmentoperators, and the difference between mutable and\nimmutable objects in Python. This discussion applies in general when augmented assignment operators are\napplied to elements of a tuple that point to mutable objects, but we’ll use\nalistand+=as our exemplar. If you wrote: The reason for the exception should be immediately clear:1is added to the\nobjecta_tuple[0]points to (1), producing the result object,2,\nbut when we attempt to assign the result of the computation,2, to element0of the tuple, we get an error because we can’t change what an element of\na tuple points to. Under the covers, what this augmented assignment statement is doing is\napproximately this: It is the assignment part of the operation that produces the error, since a\ntuple is immutable. When you write something like: The exception is a bit more surprising, and even more surprising is the fact\nthat even though there was an error, the append worked: To see why this happens, you need to know that (a) if an object implements an__iadd__()magic method, it gets called when the+=augmented\nassignment\nis executed, and its return value is what gets used in the assignment statement;\nand (b) for lists,__iadd__()is equivalent to callingextend()on the list\nand returning the list.  That’s why we say that for lists,+=is a\n“shorthand” forlist.extend(): This is equivalent to: The object pointed to by a_list has been mutated, and the pointer to the\nmutated object is assigned back toa_list.  The end result of the\nassignment is a no-op, since it is a pointer to the same object thata_listwas previously pointing to, but the assignment still happens. Thus, in our tuple example what is happening is equivalent to: The__iadd__()succeeds, and thus the list is extended, but even thoughresultpoints to the same object thata_tuple[0]already points to,\nthat final assignment still results in an error, because tuples are immutable. The technique, attributed to Randal Schwartz of the Perl community, sorts the\nelements of a list by a metric which maps each element to its “sort value”. In\nPython, use thekeyargument for thelist.sort()method: Merge them into an iterator of tuples, sort the resulting list, and then pick\nout the element you want. A class is the particular object type created by executing a class statement.\nClass objects are used as templates to create instance objects, which embody\nboth the data (attributes) and code (methods) specific to a datatype. A class can be based on one or more other classes, called its base class(es). It\nthen inherits the attributes and methods of its base classes. This allows an\nobject model to be successively refined by inheritance.  You might have a\ngenericMailboxclass that provides basic accessor methods for a mailbox,\nand subclasses such asMboxMailbox,MaildirMailbox,OutlookMailboxthat handle various specific mailbox formats. A method is a function on some objectxthat you normally call asx.name(arguments...).  Methods are defined as functions inside the class\ndefinition: Self is merely a conventional name for the first argument of a method.  A method\ndefined asmeth(self,a,b,c)should be called asx.meth(a,b,c)for\nsome instancexof the class in which the definition occurs; the called\nmethod will think it is called asmeth(x,a,b,c). See alsoWhy must ‘self’ be used explicitly in method definitions and calls?. Use the built-in functionisinstance(obj,cls).  You can\ncheck if an object\nis an instance of any of a number of classes by providing a tuple instead of a\nsingle class, e.g.isinstance(obj,(class1,class2,...)), and can also\ncheck whether an object is one of Python’s built-in types, e.g.isinstance(obj,str)orisinstance(obj,(int,float,complex)). Note thatisinstance()also checks for virtual inheritance from anabstract base class.  So, the test will returnTruefor a\nregistered class even if hasn’t directly or indirectly inherited from it.  To\ntest for “true inheritance”, scan theMROof the class: Note that most programs do not useisinstance()on user-defined classes\nvery often.  If you are developing the classes yourself, a more proper\nobject-oriented style is to define methods on the classes that encapsulate a\nparticular behaviour, instead of checking the object’s class and doing a\ndifferent thing based on what class it is.  For example, if you have a function\nthat does something: A better approach is to define asearch()method on all the classes and just\ncall it: Delegation is an object oriented technique (also called a design pattern).\nLet’s say you have an objectxand want to change the behaviour of just one\nof its methods.  You can create a new class that provides a new implementation\nof the method you’re interested in changing and delegates all other methods to\nthe corresponding method ofx. Python programmers can easily implement delegation.  For example, the following\nclass implements a class that behaves like a file but converts all written data\nto uppercase: Here theUpperOutclass redefines thewrite()method to convert the\nargument string to uppercase before calling the underlyingself._outfile.write()method.  All other methods are delegated to the\nunderlyingself._outfileobject.  The delegation is accomplished via the__getattr__()method; consultthe language referencefor more information about controlling attribute access. Note that for more general cases delegation can get trickier. When attributes\nmust be set as well as retrieved, the class must define a__setattr__()method too, and it must do so carefully.  The basic implementation of__setattr__()is roughly equivalent to the following: Most__setattr__()implementations must modifyself.__dict__to store\nlocal state for self without causing an infinite recursion. Use the built-insuper()function: In the example,super()will automatically determine the instance from\nwhich it was called (theselfvalue), look up themethod resolution\norder(MRO) withtype(self).__mro__, and return the next in line afterDerivedin the MRO:Base. You could assign the base class to an alias and derive from the alias.  Then all\nyou have to change is the value assigned to the alias.  Incidentally, this trick\nis also handy if you want to decide dynamically (e.g. depending on availability\nof resources) which base class to use.  Example: Both static data and static methods (in the sense of C++ or Java) are supported\nin Python. For static data, simply define a class attribute.  To assign a new value to the\nattribute, you have to explicitly use the class name in the assignment: c.countalso refers toC.countfor anycsuch thatisinstance(c,C)holds, unless overridden bycitself or by some class on the base-class\nsearch path fromc.__class__back toC. Caution: within a method of C, an assignment likeself.count=42creates a\nnew and unrelated instance named “count” inself’s own dict.  Rebinding of a\nclass-static data name must always specify the class whether inside a method or\nnot: Static methods are possible: However, a far more straightforward way to get the effect of a static method is\nvia a simple module-level function: If your code is structured so as to define one class (or tightly related class\nhierarchy) per module, this supplies the desired encapsulation. This answer actually applies to all methods, but the question usually comes up\nfirst in the context of constructors. In C++ you’d write In Python you have to write a single constructor that catches all cases using\ndefault arguments.  For example: This is not entirely equivalent, but close enough in practice. You could also try a variable-length argument list, e.g. The same approach works for all method definitions. Variable names with double leading underscores are “mangled” to provide a simple\nbut effective way to define class private variables.  Any identifier of the form__spam(at least two leading underscores, at most one trailing underscore)\nis textually replaced with_classname__spam, whereclassnameis the\ncurrent class name with any leading underscores stripped. The identifier can be used unchanged within the class, but to access it outside\nthe class, the mangled name must be used: In particular, this does not guarantee privacy since an outside user can still\ndeliberately access the private attribute; many Python programmers never bother\nto use private variable names at all. See also Theprivate name mangling specificationsfor details and special cases. There are several possible reasons for this. Thedelstatement does not necessarily call__del__()– it simply\ndecrements the object’s reference count, and if this reaches zero__del__()is called. If your data structures contain circular links (e.g. a tree where each child has\na parent reference and each parent has a list of children) the reference counts\nwill never go back to zero.  Once in a while Python runs an algorithm to detect\nsuch cycles, but the garbage collector might run some time after the last\nreference to your data structure vanishes, so your__del__()method may be\ncalled at an inconvenient and random time. This is inconvenient if you’re trying\nto reproduce a problem. Worse, the order in which object’s__del__()methods are executed is arbitrary.  You can rungc.collect()to force a\ncollection, but therearepathological cases where objects will never be\ncollected. Despite the cycle collector, it’s still a good idea to define an explicitclose()method on objects to be called whenever you’re done with them.  Theclose()method can then remove attributes that refer to subobjects.  Don’t\ncall__del__()directly –__del__()should callclose()andclose()should make sure that it can be called more than once for the same\nobject. Another way to avoid cyclical references is to use theweakrefmodule,\nwhich allows you to point to objects without incrementing their reference count.\nTree data structures, for instance, should use weak references for their parent\nand sibling references (if they need them!). Finally, if your__del__()method raises an exception, a warning message\nis printed tosys.stderr. Python does not keep track of all instances of a class (or of a built-in type).\nYou can program the class’s constructor to keep track of all instances by\nkeeping a list of weak references to each instance. Theid()builtin returns an integer that is guaranteed to be unique during\nthe lifetime of the object.  Since in CPython, this is the object’s memory\naddress, it happens frequently that after an object is deleted from memory, the\nnext freshly created object is allocated at the same position in memory.  This\nis illustrated by this example: The two ids belong to different integer objects that are created before, and\ndeleted immediately after execution of theid()call.  To be sure that\nobjects whose id you want to examine are still alive, create another reference\nto the object: Theisoperator tests for object identity.  The testaisbis\nequivalent toid(a)==id(b). The most important property of an identity test is that an object is always\nidentical to itself,aisaalways returnsTrue.  Identity tests are\nusually faster than equality tests.  And unlike equality tests, identity tests\nare guaranteed to return a booleanTrueorFalse. However, identity tests canonlybe substituted for equality tests when\nobject identity is assured.  Generally, there are three circumstances where\nidentity is guaranteed: 1) Assignments create new names but do not change object identity.  After the\nassignmentnew=old, it is guaranteed thatnewisold. 2) Putting an object in a container that stores object references does not\nchange object identity.  After the list assignments[0]=x, it is\nguaranteed thats[0]isx. 3) If an object is a singleton, it means that only one instance of that object\ncan exist.  After the assignmentsa=Noneandb=None, it is\nguaranteed thataisbbecauseNoneis a singleton. In most other circumstances, identity tests are inadvisable and equality tests\nare preferred.  In particular, identity tests should not be used to check\nconstants such asintandstrwhich aren’t guaranteed to be\nsingletons: Likewise, new instances of mutable containers are never identical: In the standard library code, you will see several common patterns for\ncorrectly using identity tests: 1) As recommended byPEP 8, an identity test is the preferred way to check\nforNone.  This reads like plain English in code and avoids confusion with\nother objects that may have boolean values that evaluate to false. 2) Detecting optional arguments can be tricky whenNoneis a valid input\nvalue.  In those situations, you can create a singleton sentinel object\nguaranteed to be distinct from other objects.  For example, here is how\nto implement a method that behaves likedict.pop(): 3) Container implementations sometimes need to augment equality tests with\nidentity tests.  This prevents the code from being confused by objects such asfloat('NaN')that are not equal to themselves. For example, here is the implementation ofcollections.abc.Sequence.__contains__(): When subclassing an immutable type, override the__new__()method\ninstead of the__init__()method.  The latter only runsafteran\ninstance is created, which is too late to alter data in an immutable\ninstance. All of these immutable classes have a different signature than their\nparent class: The classes can be used like this: The two principal tools for caching methods arefunctools.cached_property()andfunctools.lru_cache().  The\nformer stores results at the instance level and the latter at the class\nlevel. Thecached_propertyapproach only works with methods that do not take\nany arguments.  It does not create a reference to the instance.  The\ncached method result will be kept only as long as the instance is alive. The advantage is that when an instance is no longer used, the cached\nmethod result will be released right away.  The disadvantage is that if\ninstances accumulate, so too will the accumulated method results.  They\ncan grow without bound. Thelru_cacheapproach works with methods that havehashablearguments.  It creates a reference to the instance unless special\nefforts are made to pass in weak references. The advantage of the least recently used algorithm is that the cache is\nbounded by the specifiedmaxsize.  The disadvantage is that instances\nare kept alive until they age out of the cache or until the cache is\ncleared. This example shows the various techniques: The above example assumes that thestation_idnever changes.  If the\nrelevant instance attributes are mutable, thecached_propertyapproach\ncan’t be made to work because it cannot detect changes to the\nattributes. To make thelru_cacheapproach work when thestation_idis mutable,\nthe class needs to define the__eq__()and__hash__()methods so that the cache can detect relevant attribute updates: When a module is imported for the first time (or when the source file has\nchanged since the current compiled file was created) a.pycfile containing\nthe compiled code should be created in a__pycache__subdirectory of the\ndirectory containing the.pyfile.  The.pycfile will have a\nfilename that starts with the same name as the.pyfile, and ends with.pyc, with a middle component that depends on the particularpythonbinary that created it.  (SeePEP 3147for details.) One reason that a.pycfile may not be created is a permissions problem\nwith the directory containing the source file, meaning that the__pycache__subdirectory cannot be created. This can happen, for example, if you develop as\none user but run as another, such as if you are testing with a web server. Unless thePYTHONDONTWRITEBYTECODEenvironment variable is set,\ncreation of a .pyc file is automatic if you’re importing a module and Python\nhas the ability (permissions, free space, etc…) to create a__pycache__subdirectory and write the compiled module to that subdirectory. Running Python on a top level script is not considered an import and no.pycwill be created.  For example, if you have a top-level modulefoo.pythat imports another modulexyz.py, when you runfoo(by\ntypingpythonfoo.pyas a shell command), a.pycwill be created forxyzbecausexyzis imported, but no.pycfile will be created forfoosincefoo.pyisn’t being imported. If you need to create a.pycfile forfoo– that is, to create a.pycfile for a module that is not imported – you can, using thepy_compileandcompileallmodules. Thepy_compilemodule can manually compile any module.  One way is to use\nthecompile()function in that module interactively: This will write the.pycto a__pycache__subdirectory in the same\nlocation asfoo.py(or you can override that with the optional parametercfile). You can also automatically compile all files in a directory or directories using\nthecompileallmodule.  You can do it from the shell prompt by runningcompileall.pyand providing the path of a directory containing Python files\nto compile: A module can find out its own module name by looking at the predefined global\nvariable__name__.  If this has the value'__main__', the program is\nrunning as a script.  Many modules that are usually used by importing them also\nprovide a command-line interface or a self-test, and only execute this code\nafter checking__name__: Suppose you have the following modules: foo.py: bar.py: The problem is that the interpreter will perform the following steps: main importsfoo Empty globals forfooare created foois compiled and starts executing fooimportsbar Empty globals forbarare created baris compiled and starts executing barimportsfoo(which is a no-op since there already is a module namedfoo) The import mechanism tries to readfoo_varfromfooglobals, to setbar.foo_var=foo.foo_var The last step fails, because Python isn’t done with interpretingfooyet and\nthe global symbol dictionary forfoois still empty. The same thing happens when you useimportfoo, and then try to accessfoo.foo_varin global code. There are (at least) three possible workarounds for this problem. Guido van Rossum recommends avoiding all uses offrom<module>import...,\nand placing all code inside functions.  Initializations of global variables and\nclass variables should use constants or built-in functions only.  This means\neverything from an imported module is referenced as<module>.<name>. Jim Roskind suggests performing steps in the following order in each module: exports (globals, functions, and classes that don’t need imported base\nclasses) importstatements active code (including globals that are initialized from imported values). Van Rossum doesn’t like this approach much because the imports appear in a\nstrange place, but it does work. Matthias Urlichs recommends restructuring your code so that the recursive import\nis not necessary in the first place. These solutions are not mutually exclusive. Consider using the convenience functionimport_module()fromimportlibinstead: For reasons of efficiency as well as consistency, Python only reads the module\nfile on the first time a module is imported.  If it didn’t, in a program\nconsisting of many modules where each one imports the same basic module, the\nbasic module would be parsed and re-parsed many times.  To force re-reading of a\nchanged module, do this: Warning: this technique is not 100% fool-proof.  In particular, modules\ncontaining statements like will continue to work with the old version of the imported objects.  If the\nmodule contains class definitions, existing class instances willnotbe\nupdated to use the new class definition.  This can result in the following\nparadoxical behaviour: The nature of the problem is made clear if you print out the “identity” of the\nclass objects:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "General Questions¶",
        "answer": "Yes. Several debuggers for Python are described below, and the built-in functionbreakpoint()allows you to drop into any of them. The pdb module is a simple but adequate console-mode debugger for Python. It is\npart of the standard Python library, and isdocumentedintheLibraryReferenceManual. You can also write your own debugger by using the code\nfor pdb as an example. The IDLE interactive development environment, which is part of the standard\nPython distribution (normally available asTools/scripts/idle3),\nincludes a graphical debugger. PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The\nPythonWin debugger colors breakpoints and has quite a few cool features such as\ndebugging non-PythonWin programs.  PythonWin is available as part ofpywin32project and\nas a part of theActivePythondistribution. Ericis an IDE built on PyQt\nand the Scintilla editing component. trepan3kis a gdb-like debugger. Visual Studio Codeis an IDE with debugging\ntools that integrates with version-control software. There are a number of commercial Python IDEs that include graphical debuggers.\nThey include: Wing IDE Komodo IDE PyCharm Yes. PylintandPyflakesdo basic checking that will\nhelp you catch bugs sooner. Static type checkers such asMypy,Pyre, andPytypecan check type hints in Python\nsource code. You don’t need the ability to compile Python to C code if all you want is a\nstand-alone program that users can download and run without having to install\nthe Python distribution first.  There are a number of tools that determine the\nset of modules required by a program and bind these modules together with a\nPython binary to produce a single executable. One is to use the freeze tool, which is included in the Python source tree asTools/freeze.\nIt converts Python byte code to C arrays; with a C compiler you can\nembed all your modules into a new program, which is then linked with the\nstandard Python modules. It works by scanning your source recursively for import statements (in both\nforms) and looking for the modules in the standard Python path as well as in the\nsource directory (for built-in modules).  It then turns the bytecode for modules\nwritten in Python into C code (array initializers that can be turned into code\nobjects using the marshal module) and creates a custom-made config file that\nonly contains those built-in modules which are actually used in the program.  It\nthen compiles the generated C code and links it with the rest of the Python\ninterpreter to form a self-contained binary which acts exactly like your script. The following packages can help with the creation of console and GUI\nexecutables: Nuitka(Cross-platform) PyInstaller(Cross-platform) PyOxidizer(Cross-platform) cx_Freeze(Cross-platform) py2app(macOS only) py2exe(Windows only) Yes.  The coding style required for standard library modules is documented asPEP 8.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Is there a source code level debugger with breakpoints, single-stepping, etc.?¶",
        "answer": "Yes. Several debuggers for Python are described below, and the built-in functionbreakpoint()allows you to drop into any of them. The pdb module is a simple but adequate console-mode debugger for Python. It is\npart of the standard Python library, and isdocumentedintheLibraryReferenceManual. You can also write your own debugger by using the code\nfor pdb as an example. The IDLE interactive development environment, which is part of the standard\nPython distribution (normally available asTools/scripts/idle3),\nincludes a graphical debugger. PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The\nPythonWin debugger colors breakpoints and has quite a few cool features such as\ndebugging non-PythonWin programs.  PythonWin is available as part ofpywin32project and\nas a part of theActivePythondistribution. Ericis an IDE built on PyQt\nand the Scintilla editing component. trepan3kis a gdb-like debugger. Visual Studio Codeis an IDE with debugging\ntools that integrates with version-control software. There are a number of commercial Python IDEs that include graphical debuggers.\nThey include: Wing IDE Komodo IDE PyCharm",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Are there tools to help find bugs or perform static analysis?¶",
        "answer": "Yes. PylintandPyflakesdo basic checking that will\nhelp you catch bugs sooner. Static type checkers such asMypy,Pyre, andPytypecan check type hints in Python\nsource code.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I create a stand-alone binary from a Python script?¶",
        "answer": "You don’t need the ability to compile Python to C code if all you want is a\nstand-alone program that users can download and run without having to install\nthe Python distribution first.  There are a number of tools that determine the\nset of modules required by a program and bind these modules together with a\nPython binary to produce a single executable. One is to use the freeze tool, which is included in the Python source tree asTools/freeze.\nIt converts Python byte code to C arrays; with a C compiler you can\nembed all your modules into a new program, which is then linked with the\nstandard Python modules. It works by scanning your source recursively for import statements (in both\nforms) and looking for the modules in the standard Python path as well as in the\nsource directory (for built-in modules).  It then turns the bytecode for modules\nwritten in Python into C code (array initializers that can be turned into code\nobjects using the marshal module) and creates a custom-made config file that\nonly contains those built-in modules which are actually used in the program.  It\nthen compiles the generated C code and links it with the rest of the Python\ninterpreter to form a self-contained binary which acts exactly like your script. The following packages can help with the creation of console and GUI\nexecutables: Nuitka(Cross-platform) PyInstaller(Cross-platform) PyOxidizer(Cross-platform) cx_Freeze(Cross-platform) py2app(macOS only) py2exe(Windows only)",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Are there coding standards or a style guide for Python programs?¶",
        "answer": "Yes.  The coding style required for standard library modules is documented asPEP 8.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Core Language¶",
        "answer": "It can be a surprise to get theUnboundLocalErrorin previously working\ncode when it is modified by adding an assignment statement somewhere in\nthe body of a function. This code: works, but this code: results in anUnboundLocalError: This is because when you make an assignment to a variable in a scope, that\nvariable becomes local to that scope and shadows any similarly named variable\nin the outer scope.  Since the last statement in foo assigns a new value tox, the compiler recognizes it as a local variable.  Consequently when the\nearlierprint(x)attempts to print the uninitialized local variable and\nan error results. In the example above you can access the outer scope variable by declaring it\nglobal: This explicit declaration is required in order to remind you that (unlike the\nsuperficially analogous situation with class and instance variables) you are\nactually modifying the value of the variable in the outer scope: You can do a similar thing in a nested scope using thenonlocalkeyword: In Python, variables that are only referenced inside a function are implicitly\nglobal.  If a variable is assigned a value anywhere within the function’s body,\nit’s assumed to be a local unless explicitly declared as global. Though a bit surprising at first, a moment’s consideration explains this.  On\none hand, requiringglobalfor assigned variables provides a bar\nagainst unintended side-effects.  On the other hand, ifglobalwas required\nfor all global references, you’d be usingglobalall the time.  You’d have\nto declare as global every reference to a built-in function or to a component of\nan imported module.  This clutter would defeat the usefulness of theglobaldeclaration for identifying side-effects. Assume you use a for loop to define a few different lambdas (or even plain\nfunctions), e.g.: This gives you a list that contains 5 lambdas that calculatex**2.  You\nmight expect that, when called, they would return, respectively,0,1,4,9, and16.  However, when you actually try you will see that\nthey all return16: This happens becausexis not local to the lambdas, but is defined in\nthe outer scope, and it is accessed when the lambda is called — not when it\nis defined.  At the end of the loop, the value ofxis4, so all the\nfunctions now return4**2, i.e.16.  You can also verify this by\nchanging the value ofxand see how the results of the lambdas change: In order to avoid this, you need to save the values in variables local to the\nlambdas, so that they don’t rely on the value of the globalx: Here,n=xcreates a new variablenlocal to the lambda and computed\nwhen the lambda is defined so that it has the same value thatxhad at\nthat point in the loop.  This means that the value ofnwill be0in the first lambda,1in the second,2in the third, and so on.\nTherefore each lambda will now return the correct result: Note that this behaviour is not peculiar to lambdas, but applies to regular\nfunctions too. The canonical way to share information across modules within a single program is\nto create a special module (often called config or cfg).  Just import the config\nmodule in all modules of your application; the module then becomes available as\na global name.  Because there is only one instance of each module, any changes\nmade to the module object get reflected everywhere.  For example: config.py: mod.py: main.py: Note that using a module is also the basis for implementing the singleton design\npattern, for the same reason. In general, don’t usefrommodulenameimport*.  Doing so clutters the\nimporter’s namespace, and makes it much harder for linters to detect undefined\nnames. Import modules at the top of a file.  Doing so makes it clear what other modules\nyour code requires and avoids questions of whether the module name is in scope.\nUsing one import per line makes it easy to add and delete module imports, but\nusing multiple imports per line uses less screen space. It’s good practice if you import modules in the following order: standard library modules – e.g.sys,os,argparse,re third-party library modules (anything installed in Python’s site-packages\ndirectory) – e.g.dateutil,requests,PIL.Image locally developed modules It is sometimes necessary to move imports to a function or class to avoid\nproblems with circular imports.  Gordon McMillan says: Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. In this case, if the second module is only used in one function, then the import\ncan easily be moved into that function.  By the time the import is called, the\nfirst module will have finished initializing, and the second module can do its\nimport. It may also be necessary to move imports out of the top level of code if some of\nthe modules are platform-specific.  In that case, it may not even be possible to\nimport all of the modules at the top of the file.  In this case, importing the\ncorrect modules in the corresponding platform-specific code is a good option. Only move imports into a local scope, such as inside a function definition, if\nit’s necessary to solve a problem such as avoiding a circular import or are\ntrying to reduce the initialization time of a module.  This technique is\nespecially helpful if many of the imports are unnecessary depending on how the\nprogram executes.  You may also want to move imports into a function if the\nmodules are only ever used in that function.  Note that loading a module the\nfirst time may be expensive because of the one time initialization of the\nmodule, but loading a module multiple times is virtually free, costing only a\ncouple of dictionary lookups.  Even if the module name has gone out of scope,\nthe module is probably available insys.modules. This type of bug commonly bites neophyte programmers.  Consider this function: The first time you call this function,mydictcontains a single item.  The\nsecond time,mydictcontains two items because whenfoo()begins\nexecuting,mydictstarts out with an item already in it. It is often expected that a function call creates new objects for default\nvalues. This is not what happens. Default values are created exactly once, when\nthe function is defined.  If that object is changed, like the dictionary in this\nexample, subsequent calls to the function will refer to this changed object. By definition, immutable objects such as numbers, strings, tuples, andNone,\nare safe from change. Changes to mutable objects such as dictionaries, lists,\nand class instances can lead to confusion. Because of this feature, it is good programming practice to not use mutable\nobjects as default values.  Instead, useNoneas the default value and\ninside the function, check if the parameter isNoneand create a new\nlist/dictionary/whatever if it is.  For example, don’t write: but: This feature can be useful.  When you have a function that’s time-consuming to\ncompute, a common technique is to cache the parameters and the resulting value\nof each call to the function, and return the cached value if the same value is\nrequested again.  This is called “memoizing”, and can be implemented like this: You could use a global variable containing a dictionary instead of the default\nvalue; it’s a matter of taste. Collect the arguments using the*and**specifiers in the function’s\nparameter list; this gives you the positional arguments as a tuple and the\nkeyword arguments as a dictionary.  You can then pass these arguments when\ncalling another function by using*and**: Parametersare defined by the names that appear in a\nfunction definition, whereasargumentsare the values\nactually passed to a function when calling it.  Parameters define whatkind of argumentsa function can accept.  For\nexample, given the function definition: foo,barandkwargsare parameters offunc.  However, when callingfunc, for example: the values42,314, andsomevarare arguments. If you wrote code like: you might be wondering why appending an element toychangedxtoo. There are two factors that produce this result: Variables are simply names that refer to objects.  Doingy=xdoesn’t\ncreate a copy of the list – it creates a new variableythat refers to\nthe same objectxrefers to.  This means that there is only one object\n(the list), and bothxandyrefer to it. Lists aremutable, which means that you can change their content. After the call toappend(), the content of the mutable object has\nchanged from[]to[10].  Since both the variables refer to the same\nobject, using either name accesses the modified value[10]. If we instead assign an immutable object tox: we can see that in this casexandyare not equal anymore.  This is\nbecause integers areimmutable, and when we dox=x+1we are not\nmutating the int5by incrementing its value; instead, we are creating a\nnew object (the int6) and assigning it tox(that is, changing which\nobjectxrefers to).  After this assignment we have two objects (the ints6and5) and two variables that refer to them (xnow refers to6butystill refers to5). Some operations (for exampley.append(10)andy.sort()) mutate the\nobject, whereas superficially similar operations (for exampley=y+[10]andsorted(y)) create a new object.  In general in Python (and in all cases\nin the standard library) a method that mutates an object will returnNoneto help avoid getting the two types of operations confused.  So if you\nmistakenly writey.sort()thinking it will give you a sorted copy ofy,\nyou’ll instead end up withNone, which will likely cause your program to\ngenerate an easily diagnosed error. However, there is one class of operations where the same operation sometimes\nhas different behaviors with different types:  the augmented assignment\noperators.  For example,+=mutates lists but not tuples or ints (a_list+=[1,2,3]is equivalent toa_list.extend([1,2,3])and mutatesa_list, whereassome_tuple+=(1,2,3)andsome_int+=1create\nnew objects). In other words: If we have a mutable object (list,dict,set,\netc.), we can use some specific operations to mutate it and all the variables\nthat refer to it will see the change. If we have an immutable object (str,int,tuple,\netc.), all the variables that refer to it will always see the same value,\nbut operations that transform that value into a new value always return a new\nobject. If you want to know if two variables refer to the same object or not, you can\nuse theisoperator, or the built-in functionid(). Remember that arguments are passed by assignment in Python.  Since assignment\njust creates references to objects, there’s no alias between an argument name in\nthe caller and callee, and so no call-by-reference per se.  You can achieve the\ndesired effect in a number of ways. By returning a tuple of the results: This is almost always the clearest solution. By using global variables.  This isn’t thread-safe, and is not recommended. By passing a mutable (changeable in-place) object: By passing in a dictionary that gets mutated: Or bundle up values in a class instance: There’s almost never a good reason to get this complicated. Your best choice is to return a tuple containing the multiple results. You have two choices: you can use nested scopes or you can use callable objects.\nFor example, suppose you wanted to definelinear(a,b)which returns a\nfunctionf(x)that computes the valuea*x+b.  Using nested scopes: Or using a callable object: In both cases, gives a callable object wheretaxes(10e6)==0.3*10e6+2. The callable object approach has the disadvantage that it is a bit slower and\nresults in slightly longer code.  However, note that a collection of callables\ncan share their signature via inheritance: Object can encapsulate state for several methods: Hereinc(),dec()andreset()act like functions which share the\nsame counting variable. In general, trycopy.copy()orcopy.deepcopy()for the general case.\nNot all objects can be copied, but most can. Some objects can be copied more easily.  Dictionaries have acopy()method: Sequences can be copied by slicing: For an instancexof a user-defined class,dir(x)returns an alphabetized\nlist of the names containing the instance attributes and methods and attributes\ndefined by its class. Generally speaking, it can’t, because objects don’t really have names.\nEssentially, assignment always binds a name to a value; the same is true ofdefandclassstatements, but in that case the value is a\ncallable. Consider the following code: Arguably the class has a name: even though it is bound to two names and invoked\nthrough the nameBthe created instance is still reported as an instance of\nclassA.  However, it is impossible to say whether the instance’s name isaorb, since both names are bound to the same value. Generally speaking it should not be necessary for your code to “know the names”\nof particular values. Unless you are deliberately writing introspective\nprograms, this is usually an indication that a change of approach might be\nbeneficial. In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to\nthis question: The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)…….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all! The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)… ….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all! Comma is not an operator in Python.  Consider this session: Since the comma is not an operator, but a separator between expressions the\nabove is evaluated as if you had entered: not: The same is true of the various assignment operators (=,+=etc).  They\nare not truly operators but syntactic delimiters in assignment statements. Yes, there is. The syntax is as follows: Before this syntax was introduced in Python 2.5, a common idiom was to use\nlogical operators: However, this idiom is unsafe, as it can give wrong results whenon_truehas a false boolean value.  Therefore, it is always better to use\nthe...if...else...form. Yes.  Usually this is done by nestinglambdawithinlambda.  See the following three examples, slightly adapted from Ulf Bartelt: Don’t try this at home, kids! A slash in the argument list of a function denotes that the parameters prior to\nit are positional-only.  Positional-only parameters are the ones without an\nexternally usable name.  Upon calling a function that accepts positional-only\nparameters, arguments are mapped to parameters based solely on their position.\nFor example,divmod()is a function that accepts positional-only\nparameters. Its documentation looks like this: The slash at the end of the parameter list means that both parameters are\npositional-only. Thus, callingdivmod()with keyword arguments would lead\nto an error:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why am I getting an UnboundLocalError when the variable has a value?¶",
        "answer": "It can be a surprise to get theUnboundLocalErrorin previously working\ncode when it is modified by adding an assignment statement somewhere in\nthe body of a function. This code: works, but this code: results in anUnboundLocalError: This is because when you make an assignment to a variable in a scope, that\nvariable becomes local to that scope and shadows any similarly named variable\nin the outer scope.  Since the last statement in foo assigns a new value tox, the compiler recognizes it as a local variable.  Consequently when the\nearlierprint(x)attempts to print the uninitialized local variable and\nan error results. In the example above you can access the outer scope variable by declaring it\nglobal: This explicit declaration is required in order to remind you that (unlike the\nsuperficially analogous situation with class and instance variables) you are\nactually modifying the value of the variable in the outer scope: You can do a similar thing in a nested scope using thenonlocalkeyword:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What are the rules for local and global variables in Python?¶",
        "answer": "In Python, variables that are only referenced inside a function are implicitly\nglobal.  If a variable is assigned a value anywhere within the function’s body,\nit’s assumed to be a local unless explicitly declared as global. Though a bit surprising at first, a moment’s consideration explains this.  On\none hand, requiringglobalfor assigned variables provides a bar\nagainst unintended side-effects.  On the other hand, ifglobalwas required\nfor all global references, you’d be usingglobalall the time.  You’d have\nto declare as global every reference to a built-in function or to a component of\nan imported module.  This clutter would defeat the usefulness of theglobaldeclaration for identifying side-effects.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why do lambdas defined in a loop with different values all return the same result?¶",
        "answer": "Assume you use a for loop to define a few different lambdas (or even plain\nfunctions), e.g.: This gives you a list that contains 5 lambdas that calculatex**2.  You\nmight expect that, when called, they would return, respectively,0,1,4,9, and16.  However, when you actually try you will see that\nthey all return16: This happens becausexis not local to the lambdas, but is defined in\nthe outer scope, and it is accessed when the lambda is called — not when it\nis defined.  At the end of the loop, the value ofxis4, so all the\nfunctions now return4**2, i.e.16.  You can also verify this by\nchanging the value ofxand see how the results of the lambdas change: In order to avoid this, you need to save the values in variables local to the\nlambdas, so that they don’t rely on the value of the globalx: Here,n=xcreates a new variablenlocal to the lambda and computed\nwhen the lambda is defined so that it has the same value thatxhad at\nthat point in the loop.  This means that the value ofnwill be0in the first lambda,1in the second,2in the third, and so on.\nTherefore each lambda will now return the correct result: Note that this behaviour is not peculiar to lambdas, but applies to regular\nfunctions too.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I share global variables across modules?¶",
        "answer": "The canonical way to share information across modules within a single program is\nto create a special module (often called config or cfg).  Just import the config\nmodule in all modules of your application; the module then becomes available as\na global name.  Because there is only one instance of each module, any changes\nmade to the module object get reflected everywhere.  For example: config.py: mod.py: main.py: Note that using a module is also the basis for implementing the singleton design\npattern, for the same reason.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What are the “best practices” for using import in a module?¶",
        "answer": "In general, don’t usefrommodulenameimport*.  Doing so clutters the\nimporter’s namespace, and makes it much harder for linters to detect undefined\nnames. Import modules at the top of a file.  Doing so makes it clear what other modules\nyour code requires and avoids questions of whether the module name is in scope.\nUsing one import per line makes it easy to add and delete module imports, but\nusing multiple imports per line uses less screen space. It’s good practice if you import modules in the following order: standard library modules – e.g.sys,os,argparse,re third-party library modules (anything installed in Python’s site-packages\ndirectory) – e.g.dateutil,requests,PIL.Image locally developed modules It is sometimes necessary to move imports to a function or class to avoid\nproblems with circular imports.  Gordon McMillan says: Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. Circular imports are fine where both modules use the “import <module>” form\nof import.  They fail when the 2nd module wants to grab a name out of the\nfirst (“from module import name”) and the import is at the top level.  That’s\nbecause names in the 1st are not yet available, because the first module is\nbusy importing the 2nd. In this case, if the second module is only used in one function, then the import\ncan easily be moved into that function.  By the time the import is called, the\nfirst module will have finished initializing, and the second module can do its\nimport. It may also be necessary to move imports out of the top level of code if some of\nthe modules are platform-specific.  In that case, it may not even be possible to\nimport all of the modules at the top of the file.  In this case, importing the\ncorrect modules in the corresponding platform-specific code is a good option. Only move imports into a local scope, such as inside a function definition, if\nit’s necessary to solve a problem such as avoiding a circular import or are\ntrying to reduce the initialization time of a module.  This technique is\nespecially helpful if many of the imports are unnecessary depending on how the\nprogram executes.  You may also want to move imports into a function if the\nmodules are only ever used in that function.  Note that loading a module the\nfirst time may be expensive because of the one time initialization of the\nmodule, but loading a module multiple times is virtually free, costing only a\ncouple of dictionary lookups.  Even if the module name has gone out of scope,\nthe module is probably available insys.modules.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why are default values shared between objects?¶",
        "answer": "This type of bug commonly bites neophyte programmers.  Consider this function: The first time you call this function,mydictcontains a single item.  The\nsecond time,mydictcontains two items because whenfoo()begins\nexecuting,mydictstarts out with an item already in it. It is often expected that a function call creates new objects for default\nvalues. This is not what happens. Default values are created exactly once, when\nthe function is defined.  If that object is changed, like the dictionary in this\nexample, subsequent calls to the function will refer to this changed object. By definition, immutable objects such as numbers, strings, tuples, andNone,\nare safe from change. Changes to mutable objects such as dictionaries, lists,\nand class instances can lead to confusion. Because of this feature, it is good programming practice to not use mutable\nobjects as default values.  Instead, useNoneas the default value and\ninside the function, check if the parameter isNoneand create a new\nlist/dictionary/whatever if it is.  For example, don’t write: but: This feature can be useful.  When you have a function that’s time-consuming to\ncompute, a common technique is to cache the parameters and the resulting value\nof each call to the function, and return the cached value if the same value is\nrequested again.  This is called “memoizing”, and can be implemented like this: You could use a global variable containing a dictionary instead of the default\nvalue; it’s a matter of taste.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I pass optional or keyword parameters from one function to another?¶",
        "answer": "Collect the arguments using the*and**specifiers in the function’s\nparameter list; this gives you the positional arguments as a tuple and the\nkeyword arguments as a dictionary.  You can then pass these arguments when\ncalling another function by using*and**:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is the difference between arguments and parameters?¶",
        "answer": "Parametersare defined by the names that appear in a\nfunction definition, whereasargumentsare the values\nactually passed to a function when calling it.  Parameters define whatkind of argumentsa function can accept.  For\nexample, given the function definition: foo,barandkwargsare parameters offunc.  However, when callingfunc, for example: the values42,314, andsomevarare arguments.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why did changing list ‘y’ also change list ‘x’?¶",
        "answer": "If you wrote code like: you might be wondering why appending an element toychangedxtoo. There are two factors that produce this result: Variables are simply names that refer to objects.  Doingy=xdoesn’t\ncreate a copy of the list – it creates a new variableythat refers to\nthe same objectxrefers to.  This means that there is only one object\n(the list), and bothxandyrefer to it. Lists aremutable, which means that you can change their content. After the call toappend(), the content of the mutable object has\nchanged from[]to[10].  Since both the variables refer to the same\nobject, using either name accesses the modified value[10]. If we instead assign an immutable object tox: we can see that in this casexandyare not equal anymore.  This is\nbecause integers areimmutable, and when we dox=x+1we are not\nmutating the int5by incrementing its value; instead, we are creating a\nnew object (the int6) and assigning it tox(that is, changing which\nobjectxrefers to).  After this assignment we have two objects (the ints6and5) and two variables that refer to them (xnow refers to6butystill refers to5). Some operations (for exampley.append(10)andy.sort()) mutate the\nobject, whereas superficially similar operations (for exampley=y+[10]andsorted(y)) create a new object.  In general in Python (and in all cases\nin the standard library) a method that mutates an object will returnNoneto help avoid getting the two types of operations confused.  So if you\nmistakenly writey.sort()thinking it will give you a sorted copy ofy,\nyou’ll instead end up withNone, which will likely cause your program to\ngenerate an easily diagnosed error. However, there is one class of operations where the same operation sometimes\nhas different behaviors with different types:  the augmented assignment\noperators.  For example,+=mutates lists but not tuples or ints (a_list+=[1,2,3]is equivalent toa_list.extend([1,2,3])and mutatesa_list, whereassome_tuple+=(1,2,3)andsome_int+=1create\nnew objects). In other words: If we have a mutable object (list,dict,set,\netc.), we can use some specific operations to mutate it and all the variables\nthat refer to it will see the change. If we have an immutable object (str,int,tuple,\netc.), all the variables that refer to it will always see the same value,\nbut operations that transform that value into a new value always return a new\nobject. If you want to know if two variables refer to the same object or not, you can\nuse theisoperator, or the built-in functionid().",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I write a function with output parameters (call by reference)?¶",
        "answer": "Remember that arguments are passed by assignment in Python.  Since assignment\njust creates references to objects, there’s no alias between an argument name in\nthe caller and callee, and so no call-by-reference per se.  You can achieve the\ndesired effect in a number of ways. By returning a tuple of the results: This is almost always the clearest solution. By using global variables.  This isn’t thread-safe, and is not recommended. By passing a mutable (changeable in-place) object: By passing in a dictionary that gets mutated: Or bundle up values in a class instance: There’s almost never a good reason to get this complicated. Your best choice is to return a tuple containing the multiple results.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do you make a higher order function in Python?¶",
        "answer": "You have two choices: you can use nested scopes or you can use callable objects.\nFor example, suppose you wanted to definelinear(a,b)which returns a\nfunctionf(x)that computes the valuea*x+b.  Using nested scopes: Or using a callable object: In both cases, gives a callable object wheretaxes(10e6)==0.3*10e6+2. The callable object approach has the disadvantage that it is a bit slower and\nresults in slightly longer code.  However, note that a collection of callables\ncan share their signature via inheritance: Object can encapsulate state for several methods: Hereinc(),dec()andreset()act like functions which share the\nsame counting variable.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I copy an object in Python?¶",
        "answer": "In general, trycopy.copy()orcopy.deepcopy()for the general case.\nNot all objects can be copied, but most can. Some objects can be copied more easily.  Dictionaries have acopy()method: Sequences can be copied by slicing:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I find the methods or attributes of an object?¶",
        "answer": "For an instancexof a user-defined class,dir(x)returns an alphabetized\nlist of the names containing the instance attributes and methods and attributes\ndefined by its class.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can my code discover the name of an object?¶",
        "answer": "Generally speaking, it can’t, because objects don’t really have names.\nEssentially, assignment always binds a name to a value; the same is true ofdefandclassstatements, but in that case the value is a\ncallable. Consider the following code: Arguably the class has a name: even though it is bound to two names and invoked\nthrough the nameBthe created instance is still reported as an instance of\nclassA.  However, it is impossible to say whether the instance’s name isaorb, since both names are bound to the same value. Generally speaking it should not be necessary for your code to “know the names”\nof particular values. Unless you are deliberately writing introspective\nprograms, this is usually an indication that a change of approach might be\nbeneficial. In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to\nthis question: The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)…….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all! The same way as you get the name of that cat you found on your porch: the cat\n(object) itself cannot tell you its name, and it doesn’t really care – so\nthe only way to find out what it’s called is to ask all your neighbours\n(namespaces) if it’s their cat (object)… ….and don’t be surprised if you’ll find that it’s known by many names, or\nno name at all!",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What’s up with the comma operator’s precedence?¶",
        "answer": "Comma is not an operator in Python.  Consider this session: Since the comma is not an operator, but a separator between expressions the\nabove is evaluated as if you had entered: not: The same is true of the various assignment operators (=,+=etc).  They\nare not truly operators but syntactic delimiters in assignment statements.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Is there an equivalent of C’s “?:” ternary operator?¶",
        "answer": "Yes, there is. The syntax is as follows: Before this syntax was introduced in Python 2.5, a common idiom was to use\nlogical operators: However, this idiom is unsafe, as it can give wrong results whenon_truehas a false boolean value.  Therefore, it is always better to use\nthe...if...else...form.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Is it possible to write obfuscated one-liners in Python?¶",
        "answer": "Yes.  Usually this is done by nestinglambdawithinlambda.  See the following three examples, slightly adapted from Ulf Bartelt: Don’t try this at home, kids!",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What does the slash(/) in the parameter list of a function mean?¶",
        "answer": "A slash in the argument list of a function denotes that the parameters prior to\nit are positional-only.  Positional-only parameters are the ones without an\nexternally usable name.  Upon calling a function that accepts positional-only\nparameters, arguments are mapped to parameters based solely on their position.\nFor example,divmod()is a function that accepts positional-only\nparameters. Its documentation looks like this: The slash at the end of the parameter list means that both parameters are\npositional-only. Thus, callingdivmod()with keyword arguments would lead\nto an error:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Numbers and strings¶",
        "answer": "To specify an octal digit, precede the octal value with a zero, and then a lower\nor uppercase “o”.  For example, to set the variable “a” to the octal value “10”\n(8 in decimal), type: Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero,\nand then a lower or uppercase “x”.  Hexadecimal digits can be specified in lower\nor uppercase.  For example, in the Python interpreter: It’s primarily driven by the desire thati%jhave the same sign asj.\nIf you want that, and also want: then integer division has to return the floor.  C also requires that identity to\nhold, and then compilers that truncatei//jneed to makei%jhave\nthe same sign asi. There are few real use cases fori%jwhenjis negative.  Whenjis positive, there are many, and in virtually all of them it’s more useful fori%jto be>=0.  If the clock says 10 now, what did it say 200 hours\nago?-190%12==2is useful;-190%12==-10is a bug waiting to\nbite. Trying to lookup anintliteral attribute in the normal manner gives\naSyntaxErrorbecause the period is seen as a decimal point: The solution is to separate the literal from the period\nwith either a space or parentheses. For integers, use the built-inint()type constructor, e.g.int('144')==144.  Similarly,float()converts to a floating-point number,\ne.g.float('144')==144.0. By default, these interpret the number as decimal, so thatint('0144')==144holds true, andint('0x144')raisesValueError.int(string,base)takes the base to convert from as a second optional argument, soint('0x144',16)==324.  If the base is specified as 0, the number is interpreted\nusing Python’s rules: a leading ‘0o’ indicates octal, and ‘0x’ indicates a hex\nnumber. Do not use the built-in functioneval()if all you need is to convert\nstrings to numbers.eval()will be significantly slower and it presents a\nsecurity risk: someone could pass you a Python expression that might have\nunwanted side effects.  For example, someone could pass__import__('os').system(\"rm-rf$HOME\")which would erase your home\ndirectory. eval()also has the effect of interpreting numbers as Python expressions,\nso that e.g.eval('09')gives a syntax error because Python does not allow\nleading ‘0’ in a decimal number (except ‘0’). To convert, e.g., the number144to the string'144', use the built-in type\nconstructorstr().  If you want a hexadecimal or octal representation, use\nthe built-in functionshex()oroct().  For fancy formatting, see\nthef-stringsandFormat String Syntaxsections,\ne.g.\"{:04d}\".format(144)yields'0144'and\"{:.3f}\".format(1.0/3.0)yields'0.333'. You can’t, because strings are immutable.  In most situations, you should\nsimply construct a new string from the various parts you want to assemble\nit from.  However, if you need an object with the ability to modify in-place\nunicode data, try using anio.StringIOobject or thearraymodule: There are various techniques. The best is to use a dictionary that maps strings to functions.  The primary\nadvantage of this technique is that the strings do not need to match the names\nof the functions.  This is also the primary technique used to emulate a case\nconstruct: Use the built-in functiongetattr(): Note thatgetattr()works on any object, including classes, class\ninstances, modules, and so on. This is used in several places in the standard library, like this: Uselocals()to resolve the function name: You can useS.rstrip(\"\\r\\n\")to remove all occurrences of any line\nterminator from the end of the stringSwithout removing other trailing\nwhitespace.  If the stringSrepresents more than one line, with several\nempty lines at the end, the line terminators for all the blank lines will\nbe removed: Since this is typically only desired when reading text one line at a time, usingS.rstrip()this way works well. Not as such. For simple input parsing, the easiest approach is usually to split the line into\nwhitespace-delimited words using thesplit()method of string objects\nand then convert decimal strings to numeric values usingint()orfloat().split()supports an optional “sep” parameter which is useful\nif the line uses something other than whitespace as a separator. For more complicated input parsing, regular expressions are more powerful\nthan C’ssscanfand better suited for the task. See theUnicode HOWTO. A raw string ending with an odd number of backslashes will escape the string’s quote: There are several workarounds for this. One is to use regular strings and double\nthe backslashes: Another is to concatenate a regular string containing an escaped backslash to the\nraw string: It is also possible to useos.path.join()to append a backslash on Windows: Note that while a backslash will “escape” a quote for the purposes of\ndetermining where the raw string ends, no escaping occurs when interpreting the\nvalue of the raw string. That is, the backslash remains present in the value of\nthe raw string: Also see the specification in thelanguage reference.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I specify hexadecimal and octal integers?¶",
        "answer": "To specify an octal digit, precede the octal value with a zero, and then a lower\nor uppercase “o”.  For example, to set the variable “a” to the octal value “10”\n(8 in decimal), type: Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero,\nand then a lower or uppercase “x”.  Hexadecimal digits can be specified in lower\nor uppercase.  For example, in the Python interpreter:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why does -22 // 10 return -3?¶",
        "answer": "It’s primarily driven by the desire thati%jhave the same sign asj.\nIf you want that, and also want: then integer division has to return the floor.  C also requires that identity to\nhold, and then compilers that truncatei//jneed to makei%jhave\nthe same sign asi. There are few real use cases fori%jwhenjis negative.  Whenjis positive, there are many, and in virtually all of them it’s more useful fori%jto be>=0.  If the clock says 10 now, what did it say 200 hours\nago?-190%12==2is useful;-190%12==-10is a bug waiting to\nbite.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I get int literal attribute instead of SyntaxError?¶",
        "answer": "Trying to lookup anintliteral attribute in the normal manner gives\naSyntaxErrorbecause the period is seen as a decimal point: The solution is to separate the literal from the period\nwith either a space or parentheses.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I convert a string to a number?¶",
        "answer": "For integers, use the built-inint()type constructor, e.g.int('144')==144.  Similarly,float()converts to a floating-point number,\ne.g.float('144')==144.0. By default, these interpret the number as decimal, so thatint('0144')==144holds true, andint('0x144')raisesValueError.int(string,base)takes the base to convert from as a second optional argument, soint('0x144',16)==324.  If the base is specified as 0, the number is interpreted\nusing Python’s rules: a leading ‘0o’ indicates octal, and ‘0x’ indicates a hex\nnumber. Do not use the built-in functioneval()if all you need is to convert\nstrings to numbers.eval()will be significantly slower and it presents a\nsecurity risk: someone could pass you a Python expression that might have\nunwanted side effects.  For example, someone could pass__import__('os').system(\"rm-rf$HOME\")which would erase your home\ndirectory. eval()also has the effect of interpreting numbers as Python expressions,\nso that e.g.eval('09')gives a syntax error because Python does not allow\nleading ‘0’ in a decimal number (except ‘0’).",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I convert a number to a string?¶",
        "answer": "To convert, e.g., the number144to the string'144', use the built-in type\nconstructorstr().  If you want a hexadecimal or octal representation, use\nthe built-in functionshex()oroct().  For fancy formatting, see\nthef-stringsandFormat String Syntaxsections,\ne.g.\"{:04d}\".format(144)yields'0144'and\"{:.3f}\".format(1.0/3.0)yields'0.333'.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I modify a string in place?¶",
        "answer": "You can’t, because strings are immutable.  In most situations, you should\nsimply construct a new string from the various parts you want to assemble\nit from.  However, if you need an object with the ability to modify in-place\nunicode data, try using anio.StringIOobject or thearraymodule:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I use strings to call functions/methods?¶",
        "answer": "There are various techniques. The best is to use a dictionary that maps strings to functions.  The primary\nadvantage of this technique is that the strings do not need to match the names\nof the functions.  This is also the primary technique used to emulate a case\nconstruct: Use the built-in functiongetattr(): Note thatgetattr()works on any object, including classes, class\ninstances, modules, and so on. This is used in several places in the standard library, like this: Uselocals()to resolve the function name:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?¶",
        "answer": "You can useS.rstrip(\"\\r\\n\")to remove all occurrences of any line\nterminator from the end of the stringSwithout removing other trailing\nwhitespace.  If the stringSrepresents more than one line, with several\nempty lines at the end, the line terminators for all the blank lines will\nbe removed: Since this is typically only desired when reading text one line at a time, usingS.rstrip()this way works well.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Is there a scanf() or sscanf() equivalent?¶",
        "answer": "Not as such. For simple input parsing, the easiest approach is usually to split the line into\nwhitespace-delimited words using thesplit()method of string objects\nand then convert decimal strings to numeric values usingint()orfloat().split()supports an optional “sep” parameter which is useful\nif the line uses something other than whitespace as a separator. For more complicated input parsing, regular expressions are more powerful\nthan C’ssscanfand better suited for the task.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What does ‘UnicodeDecodeError’ or ‘UnicodeEncodeError’ error  mean?¶",
        "answer": "See theUnicode HOWTO.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Can I end a raw string with an odd number of backslashes?¶",
        "answer": "A raw string ending with an odd number of backslashes will escape the string’s quote: There are several workarounds for this. One is to use regular strings and double\nthe backslashes: Another is to concatenate a regular string containing an escaped backslash to the\nraw string: It is also possible to useos.path.join()to append a backslash on Windows: Note that while a backslash will “escape” a quote for the purposes of\ndetermining where the raw string ends, no escaping occurs when interpreting the\nvalue of the raw string. That is, the backslash remains present in the value of\nthe raw string: Also see the specification in thelanguage reference.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Performance¶",
        "answer": "That’s a tough one, in general.  First, here are a list of things to\nremember before diving further: Performance characteristics vary across Python implementations.  This FAQ\nfocuses onCPython. Behaviour can vary across operating systems, especially when talking about\nI/O or multi-threading. You should always find the hot spots in your programbeforeattempting to\noptimize any code (see theprofilemodule). Writing benchmark scripts will allow you to iterate quickly when searching\nfor improvements (see thetimeitmodule). It is highly recommended to have good code coverage (through unit testing\nor any other technique) before potentially introducing regressions hidden\nin sophisticated optimizations. That being said, there are many tricks to speed up Python code.  Here are\nsome general principles which go a long way towards reaching acceptable\nperformance levels: Making your algorithms faster (or changing to faster ones) can yield\nmuch larger benefits than trying to sprinkle micro-optimization tricks\nall over your code. Use the right data structures.  Study documentation for theBuilt-in Typesand thecollectionsmodule. When the standard library provides a primitive for doing something, it is\nlikely (although not guaranteed) to be faster than any alternative you\nmay come up with.  This is doubly true for primitives written in C, such\nas builtins and some extension types.  For example, be sure to use\neither thelist.sort()built-in method or the relatedsorted()function to do sorting (and see theSorting Techniquesfor examples\nof moderately advanced usage). Abstractions tend to create indirections and force the interpreter to work\nmore.  If the levels of indirection outweigh the amount of useful work\ndone, your program will be slower.  You should avoid excessive abstraction,\nespecially under the form of tiny functions or methods (which are also often\ndetrimental to readability). If you have reached the limit of what pure Python can allow, there are tools\nto take you further away.  For example,Cythoncan\ncompile a slightly modified version of Python code into a C extension, and\ncan be used on many different platforms.  Cython can take advantage of\ncompilation (and optional type annotations) to make your code significantly\nfaster than when interpreted.  If you are confident in your C programming\nskills, you can alsowrite a C extension moduleyourself. See also The wiki page devoted toperformance tips. strandbytesobjects are immutable, therefore concatenating\nmany strings together is inefficient as each concatenation creates a new\nobject.  In the general case, the total runtime cost is quadratic in the\ntotal string length. To accumulate manystrobjects, the recommended idiom is to place\nthem into a list and callstr.join()at the end: (another reasonably efficient idiom is to useio.StringIO) To accumulate manybytesobjects, the recommended idiom is to extend\nabytearrayobject using in-place concatenation (the+=operator):",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "My program is too slow. How do I speed it up?¶",
        "answer": "That’s a tough one, in general.  First, here are a list of things to\nremember before diving further: Performance characteristics vary across Python implementations.  This FAQ\nfocuses onCPython. Behaviour can vary across operating systems, especially when talking about\nI/O or multi-threading. You should always find the hot spots in your programbeforeattempting to\noptimize any code (see theprofilemodule). Writing benchmark scripts will allow you to iterate quickly when searching\nfor improvements (see thetimeitmodule). It is highly recommended to have good code coverage (through unit testing\nor any other technique) before potentially introducing regressions hidden\nin sophisticated optimizations. That being said, there are many tricks to speed up Python code.  Here are\nsome general principles which go a long way towards reaching acceptable\nperformance levels: Making your algorithms faster (or changing to faster ones) can yield\nmuch larger benefits than trying to sprinkle micro-optimization tricks\nall over your code. Use the right data structures.  Study documentation for theBuilt-in Typesand thecollectionsmodule. When the standard library provides a primitive for doing something, it is\nlikely (although not guaranteed) to be faster than any alternative you\nmay come up with.  This is doubly true for primitives written in C, such\nas builtins and some extension types.  For example, be sure to use\neither thelist.sort()built-in method or the relatedsorted()function to do sorting (and see theSorting Techniquesfor examples\nof moderately advanced usage). Abstractions tend to create indirections and force the interpreter to work\nmore.  If the levels of indirection outweigh the amount of useful work\ndone, your program will be slower.  You should avoid excessive abstraction,\nespecially under the form of tiny functions or methods (which are also often\ndetrimental to readability). If you have reached the limit of what pure Python can allow, there are tools\nto take you further away.  For example,Cythoncan\ncompile a slightly modified version of Python code into a C extension, and\ncan be used on many different platforms.  Cython can take advantage of\ncompilation (and optional type annotations) to make your code significantly\nfaster than when interpreted.  If you are confident in your C programming\nskills, you can alsowrite a C extension moduleyourself. See also The wiki page devoted toperformance tips.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is the most efficient way to concatenate many strings together?¶",
        "answer": "strandbytesobjects are immutable, therefore concatenating\nmany strings together is inefficient as each concatenation creates a new\nobject.  In the general case, the total runtime cost is quadratic in the\ntotal string length. To accumulate manystrobjects, the recommended idiom is to place\nthem into a list and callstr.join()at the end: (another reasonably efficient idiom is to useio.StringIO) To accumulate manybytesobjects, the recommended idiom is to extend\nabytearrayobject using in-place concatenation (the+=operator):",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Sequences (Tuples/Lists)¶",
        "answer": "The type constructortuple(seq)converts any sequence (actually, any\niterable) into a tuple with the same items in the same order. For example,tuple([1,2,3])yields(1,2,3)andtuple('abc')yields('a','b','c').  If the argument is a tuple, it does not make a copy\nbut returns the same object, so it is cheap to calltuple()when you\naren’t sure that an object is already a tuple. The type constructorlist(seq)converts any sequence or iterable into a list\nwith the same items in the same order.  For example,list((1,2,3))yields[1,2,3]andlist('abc')yields['a','b','c'].  If the argument\nis a list, it makes a copy just likeseq[:]would. Python sequences are indexed with positive numbers and negative numbers.  For\npositive numbers 0 is the first index 1 is the second index and so forth.  For\nnegative indices -1 is the last index and -2 is the penultimate (next to last)\nindex and so forth.  Think ofseq[-n]as the same asseq[len(seq)-n]. Using negative indices can be very convenient.  For exampleS[:-1]is all of\nthe string except for its last character, which is useful for removing the\ntrailing newline from a string. Use thereversed()built-in function: This won’t touch your original sequence, but build a new copy with reversed\norder to iterate over. See the Python Cookbook for a long discussion of many ways to do this: https://code.activestate.com/recipes/52560/ https://code.activestate.com/recipes/52560/ If you don’t mind reordering the list, sort it and then scan from the end of the\nlist, deleting duplicates as you go: If all elements of the list may be used as set keys (i.e. they are allhashable) this is often faster This converts the list into a set, thereby removing duplicates, and then back\ninto a list. As with removing duplicates, explicitly iterating in reverse with a\ndelete condition is one possibility.  However, it is easier and faster\nto use slice replacement with an implicit or explicit forward iteration.\nHere are three variations.: The list comprehension may be fastest. Use a list: Lists are equivalent to C or Pascal arrays in their time complexity; the primary\ndifference is that a Python list can contain objects of many different types. Thearraymodule also provides methods for creating arrays of fixed types\nwith compact representations, but they are slower to index than lists.  Also\nnote thatNumPyand other third party packages define array-like structures with\nvarious characteristics as well. To get Lisp-style linked lists, you can emulatecons cellsusing tuples: If mutability is desired, you could use lists instead of tuples.  Here the\nanalogue of a Lispcarislisp_list[0]and the analogue ofcdrislisp_list[1].  Only do this if you’re sure you really need to, because it’s\nusually a lot slower than using Python lists. You probably tried to make a multidimensional array like this: This looks correct if you print it: But when you assign a value, it shows up in multiple places: The reason is that replicating a list with*doesn’t create copies, it only\ncreates references to the existing objects.  The*3creates a list\ncontaining 3 references to the same list of length two.  Changes to one row will\nshow in all rows, which is almost certainly not what you want. The suggested approach is to create a list of the desired length first and then\nfill in each element with a newly created list: This generates a list containing 3 different lists of length two.  You can also\nuse a list comprehension: Or, you can use an extension that provides a matrix datatype;NumPyis the best known. To call a method or function and accumulate the return values is a list,\nalist comprehensionis an elegant solution: To just run the method or function without saving the return values,\na plainforloop will suffice: This is because of a combination of the fact that augmented assignment\noperators areassignmentoperators, and the difference between mutable and\nimmutable objects in Python. This discussion applies in general when augmented assignment operators are\napplied to elements of a tuple that point to mutable objects, but we’ll use\nalistand+=as our exemplar. If you wrote: The reason for the exception should be immediately clear:1is added to the\nobjecta_tuple[0]points to (1), producing the result object,2,\nbut when we attempt to assign the result of the computation,2, to element0of the tuple, we get an error because we can’t change what an element of\na tuple points to. Under the covers, what this augmented assignment statement is doing is\napproximately this: It is the assignment part of the operation that produces the error, since a\ntuple is immutable. When you write something like: The exception is a bit more surprising, and even more surprising is the fact\nthat even though there was an error, the append worked: To see why this happens, you need to know that (a) if an object implements an__iadd__()magic method, it gets called when the+=augmented\nassignment\nis executed, and its return value is what gets used in the assignment statement;\nand (b) for lists,__iadd__()is equivalent to callingextend()on the list\nand returning the list.  That’s why we say that for lists,+=is a\n“shorthand” forlist.extend(): This is equivalent to: The object pointed to by a_list has been mutated, and the pointer to the\nmutated object is assigned back toa_list.  The end result of the\nassignment is a no-op, since it is a pointer to the same object thata_listwas previously pointing to, but the assignment still happens. Thus, in our tuple example what is happening is equivalent to: The__iadd__()succeeds, and thus the list is extended, but even thoughresultpoints to the same object thata_tuple[0]already points to,\nthat final assignment still results in an error, because tuples are immutable. The technique, attributed to Randal Schwartz of the Perl community, sorts the\nelements of a list by a metric which maps each element to its “sort value”. In\nPython, use thekeyargument for thelist.sort()method: Merge them into an iterator of tuples, sort the resulting list, and then pick\nout the element you want.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I convert between tuples and lists?¶",
        "answer": "The type constructortuple(seq)converts any sequence (actually, any\niterable) into a tuple with the same items in the same order. For example,tuple([1,2,3])yields(1,2,3)andtuple('abc')yields('a','b','c').  If the argument is a tuple, it does not make a copy\nbut returns the same object, so it is cheap to calltuple()when you\naren’t sure that an object is already a tuple. The type constructorlist(seq)converts any sequence or iterable into a list\nwith the same items in the same order.  For example,list((1,2,3))yields[1,2,3]andlist('abc')yields['a','b','c'].  If the argument\nis a list, it makes a copy just likeseq[:]would.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What’s a negative index?¶",
        "answer": "Python sequences are indexed with positive numbers and negative numbers.  For\npositive numbers 0 is the first index 1 is the second index and so forth.  For\nnegative indices -1 is the last index and -2 is the penultimate (next to last)\nindex and so forth.  Think ofseq[-n]as the same asseq[len(seq)-n]. Using negative indices can be very convenient.  For exampleS[:-1]is all of\nthe string except for its last character, which is useful for removing the\ntrailing newline from a string.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I iterate over a sequence in reverse order?¶",
        "answer": "Use thereversed()built-in function: This won’t touch your original sequence, but build a new copy with reversed\norder to iterate over.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do you remove duplicates from a list?¶",
        "answer": "See the Python Cookbook for a long discussion of many ways to do this: https://code.activestate.com/recipes/52560/ https://code.activestate.com/recipes/52560/ If you don’t mind reordering the list, sort it and then scan from the end of the\nlist, deleting duplicates as you go: If all elements of the list may be used as set keys (i.e. they are allhashable) this is often faster This converts the list into a set, thereby removing duplicates, and then back\ninto a list.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do you remove multiple items from a list¶",
        "answer": "As with removing duplicates, explicitly iterating in reverse with a\ndelete condition is one possibility.  However, it is easier and faster\nto use slice replacement with an implicit or explicit forward iteration.\nHere are three variations.: The list comprehension may be fastest.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do you make an array in Python?¶",
        "answer": "Use a list: Lists are equivalent to C or Pascal arrays in their time complexity; the primary\ndifference is that a Python list can contain objects of many different types. Thearraymodule also provides methods for creating arrays of fixed types\nwith compact representations, but they are slower to index than lists.  Also\nnote thatNumPyand other third party packages define array-like structures with\nvarious characteristics as well. To get Lisp-style linked lists, you can emulatecons cellsusing tuples: If mutability is desired, you could use lists instead of tuples.  Here the\nanalogue of a Lispcarislisp_list[0]and the analogue ofcdrislisp_list[1].  Only do this if you’re sure you really need to, because it’s\nusually a lot slower than using Python lists.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I create a multidimensional list?¶",
        "answer": "You probably tried to make a multidimensional array like this: This looks correct if you print it: But when you assign a value, it shows up in multiple places: The reason is that replicating a list with*doesn’t create copies, it only\ncreates references to the existing objects.  The*3creates a list\ncontaining 3 references to the same list of length two.  Changes to one row will\nshow in all rows, which is almost certainly not what you want. The suggested approach is to create a list of the desired length first and then\nfill in each element with a newly created list: This generates a list containing 3 different lists of length two.  You can also\nuse a list comprehension: Or, you can use an extension that provides a matrix datatype;NumPyis the best known.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I apply a method or function to a sequence of objects?¶",
        "answer": "To call a method or function and accumulate the return values is a list,\nalist comprehensionis an elegant solution: To just run the method or function without saving the return values,\na plainforloop will suffice:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why does a_tuple[i] += [‘item’] raise an exception when the addition works?¶",
        "answer": "This is because of a combination of the fact that augmented assignment\noperators areassignmentoperators, and the difference between mutable and\nimmutable objects in Python. This discussion applies in general when augmented assignment operators are\napplied to elements of a tuple that point to mutable objects, but we’ll use\nalistand+=as our exemplar. If you wrote: The reason for the exception should be immediately clear:1is added to the\nobjecta_tuple[0]points to (1), producing the result object,2,\nbut when we attempt to assign the result of the computation,2, to element0of the tuple, we get an error because we can’t change what an element of\na tuple points to. Under the covers, what this augmented assignment statement is doing is\napproximately this: It is the assignment part of the operation that produces the error, since a\ntuple is immutable. When you write something like: The exception is a bit more surprising, and even more surprising is the fact\nthat even though there was an error, the append worked: To see why this happens, you need to know that (a) if an object implements an__iadd__()magic method, it gets called when the+=augmented\nassignment\nis executed, and its return value is what gets used in the assignment statement;\nand (b) for lists,__iadd__()is equivalent to callingextend()on the list\nand returning the list.  That’s why we say that for lists,+=is a\n“shorthand” forlist.extend(): This is equivalent to: The object pointed to by a_list has been mutated, and the pointer to the\nmutated object is assigned back toa_list.  The end result of the\nassignment is a no-op, since it is a pointer to the same object thata_listwas previously pointing to, but the assignment still happens. Thus, in our tuple example what is happening is equivalent to: The__iadd__()succeeds, and thus the list is extended, but even thoughresultpoints to the same object thata_tuple[0]already points to,\nthat final assignment still results in an error, because tuples are immutable.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "I want to do a complicated sort: can you do a Schwartzian Transform in Python?¶",
        "answer": "The technique, attributed to Randal Schwartz of the Perl community, sorts the\nelements of a list by a metric which maps each element to its “sort value”. In\nPython, use thekeyargument for thelist.sort()method:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I sort one list by values from another list?¶",
        "answer": "Merge them into an iterator of tuples, sort the resulting list, and then pick\nout the element you want.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Objects¶",
        "answer": "A class is the particular object type created by executing a class statement.\nClass objects are used as templates to create instance objects, which embody\nboth the data (attributes) and code (methods) specific to a datatype. A class can be based on one or more other classes, called its base class(es). It\nthen inherits the attributes and methods of its base classes. This allows an\nobject model to be successively refined by inheritance.  You might have a\ngenericMailboxclass that provides basic accessor methods for a mailbox,\nand subclasses such asMboxMailbox,MaildirMailbox,OutlookMailboxthat handle various specific mailbox formats. A method is a function on some objectxthat you normally call asx.name(arguments...).  Methods are defined as functions inside the class\ndefinition: Self is merely a conventional name for the first argument of a method.  A method\ndefined asmeth(self,a,b,c)should be called asx.meth(a,b,c)for\nsome instancexof the class in which the definition occurs; the called\nmethod will think it is called asmeth(x,a,b,c). See alsoWhy must ‘self’ be used explicitly in method definitions and calls?. Use the built-in functionisinstance(obj,cls).  You can\ncheck if an object\nis an instance of any of a number of classes by providing a tuple instead of a\nsingle class, e.g.isinstance(obj,(class1,class2,...)), and can also\ncheck whether an object is one of Python’s built-in types, e.g.isinstance(obj,str)orisinstance(obj,(int,float,complex)). Note thatisinstance()also checks for virtual inheritance from anabstract base class.  So, the test will returnTruefor a\nregistered class even if hasn’t directly or indirectly inherited from it.  To\ntest for “true inheritance”, scan theMROof the class: Note that most programs do not useisinstance()on user-defined classes\nvery often.  If you are developing the classes yourself, a more proper\nobject-oriented style is to define methods on the classes that encapsulate a\nparticular behaviour, instead of checking the object’s class and doing a\ndifferent thing based on what class it is.  For example, if you have a function\nthat does something: A better approach is to define asearch()method on all the classes and just\ncall it: Delegation is an object oriented technique (also called a design pattern).\nLet’s say you have an objectxand want to change the behaviour of just one\nof its methods.  You can create a new class that provides a new implementation\nof the method you’re interested in changing and delegates all other methods to\nthe corresponding method ofx. Python programmers can easily implement delegation.  For example, the following\nclass implements a class that behaves like a file but converts all written data\nto uppercase: Here theUpperOutclass redefines thewrite()method to convert the\nargument string to uppercase before calling the underlyingself._outfile.write()method.  All other methods are delegated to the\nunderlyingself._outfileobject.  The delegation is accomplished via the__getattr__()method; consultthe language referencefor more information about controlling attribute access. Note that for more general cases delegation can get trickier. When attributes\nmust be set as well as retrieved, the class must define a__setattr__()method too, and it must do so carefully.  The basic implementation of__setattr__()is roughly equivalent to the following: Most__setattr__()implementations must modifyself.__dict__to store\nlocal state for self without causing an infinite recursion. Use the built-insuper()function: In the example,super()will automatically determine the instance from\nwhich it was called (theselfvalue), look up themethod resolution\norder(MRO) withtype(self).__mro__, and return the next in line afterDerivedin the MRO:Base. You could assign the base class to an alias and derive from the alias.  Then all\nyou have to change is the value assigned to the alias.  Incidentally, this trick\nis also handy if you want to decide dynamically (e.g. depending on availability\nof resources) which base class to use.  Example: Both static data and static methods (in the sense of C++ or Java) are supported\nin Python. For static data, simply define a class attribute.  To assign a new value to the\nattribute, you have to explicitly use the class name in the assignment: c.countalso refers toC.countfor anycsuch thatisinstance(c,C)holds, unless overridden bycitself or by some class on the base-class\nsearch path fromc.__class__back toC. Caution: within a method of C, an assignment likeself.count=42creates a\nnew and unrelated instance named “count” inself’s own dict.  Rebinding of a\nclass-static data name must always specify the class whether inside a method or\nnot: Static methods are possible: However, a far more straightforward way to get the effect of a static method is\nvia a simple module-level function: If your code is structured so as to define one class (or tightly related class\nhierarchy) per module, this supplies the desired encapsulation. This answer actually applies to all methods, but the question usually comes up\nfirst in the context of constructors. In C++ you’d write In Python you have to write a single constructor that catches all cases using\ndefault arguments.  For example: This is not entirely equivalent, but close enough in practice. You could also try a variable-length argument list, e.g. The same approach works for all method definitions. Variable names with double leading underscores are “mangled” to provide a simple\nbut effective way to define class private variables.  Any identifier of the form__spam(at least two leading underscores, at most one trailing underscore)\nis textually replaced with_classname__spam, whereclassnameis the\ncurrent class name with any leading underscores stripped. The identifier can be used unchanged within the class, but to access it outside\nthe class, the mangled name must be used: In particular, this does not guarantee privacy since an outside user can still\ndeliberately access the private attribute; many Python programmers never bother\nto use private variable names at all. See also Theprivate name mangling specificationsfor details and special cases. There are several possible reasons for this. Thedelstatement does not necessarily call__del__()– it simply\ndecrements the object’s reference count, and if this reaches zero__del__()is called. If your data structures contain circular links (e.g. a tree where each child has\na parent reference and each parent has a list of children) the reference counts\nwill never go back to zero.  Once in a while Python runs an algorithm to detect\nsuch cycles, but the garbage collector might run some time after the last\nreference to your data structure vanishes, so your__del__()method may be\ncalled at an inconvenient and random time. This is inconvenient if you’re trying\nto reproduce a problem. Worse, the order in which object’s__del__()methods are executed is arbitrary.  You can rungc.collect()to force a\ncollection, but therearepathological cases where objects will never be\ncollected. Despite the cycle collector, it’s still a good idea to define an explicitclose()method on objects to be called whenever you’re done with them.  Theclose()method can then remove attributes that refer to subobjects.  Don’t\ncall__del__()directly –__del__()should callclose()andclose()should make sure that it can be called more than once for the same\nobject. Another way to avoid cyclical references is to use theweakrefmodule,\nwhich allows you to point to objects without incrementing their reference count.\nTree data structures, for instance, should use weak references for their parent\nand sibling references (if they need them!). Finally, if your__del__()method raises an exception, a warning message\nis printed tosys.stderr. Python does not keep track of all instances of a class (or of a built-in type).\nYou can program the class’s constructor to keep track of all instances by\nkeeping a list of weak references to each instance. Theid()builtin returns an integer that is guaranteed to be unique during\nthe lifetime of the object.  Since in CPython, this is the object’s memory\naddress, it happens frequently that after an object is deleted from memory, the\nnext freshly created object is allocated at the same position in memory.  This\nis illustrated by this example: The two ids belong to different integer objects that are created before, and\ndeleted immediately after execution of theid()call.  To be sure that\nobjects whose id you want to examine are still alive, create another reference\nto the object: Theisoperator tests for object identity.  The testaisbis\nequivalent toid(a)==id(b). The most important property of an identity test is that an object is always\nidentical to itself,aisaalways returnsTrue.  Identity tests are\nusually faster than equality tests.  And unlike equality tests, identity tests\nare guaranteed to return a booleanTrueorFalse. However, identity tests canonlybe substituted for equality tests when\nobject identity is assured.  Generally, there are three circumstances where\nidentity is guaranteed: 1) Assignments create new names but do not change object identity.  After the\nassignmentnew=old, it is guaranteed thatnewisold. 2) Putting an object in a container that stores object references does not\nchange object identity.  After the list assignments[0]=x, it is\nguaranteed thats[0]isx. 3) If an object is a singleton, it means that only one instance of that object\ncan exist.  After the assignmentsa=Noneandb=None, it is\nguaranteed thataisbbecauseNoneis a singleton. In most other circumstances, identity tests are inadvisable and equality tests\nare preferred.  In particular, identity tests should not be used to check\nconstants such asintandstrwhich aren’t guaranteed to be\nsingletons: Likewise, new instances of mutable containers are never identical: In the standard library code, you will see several common patterns for\ncorrectly using identity tests: 1) As recommended byPEP 8, an identity test is the preferred way to check\nforNone.  This reads like plain English in code and avoids confusion with\nother objects that may have boolean values that evaluate to false. 2) Detecting optional arguments can be tricky whenNoneis a valid input\nvalue.  In those situations, you can create a singleton sentinel object\nguaranteed to be distinct from other objects.  For example, here is how\nto implement a method that behaves likedict.pop(): 3) Container implementations sometimes need to augment equality tests with\nidentity tests.  This prevents the code from being confused by objects such asfloat('NaN')that are not equal to themselves. For example, here is the implementation ofcollections.abc.Sequence.__contains__(): When subclassing an immutable type, override the__new__()method\ninstead of the__init__()method.  The latter only runsafteran\ninstance is created, which is too late to alter data in an immutable\ninstance. All of these immutable classes have a different signature than their\nparent class: The classes can be used like this: The two principal tools for caching methods arefunctools.cached_property()andfunctools.lru_cache().  The\nformer stores results at the instance level and the latter at the class\nlevel. Thecached_propertyapproach only works with methods that do not take\nany arguments.  It does not create a reference to the instance.  The\ncached method result will be kept only as long as the instance is alive. The advantage is that when an instance is no longer used, the cached\nmethod result will be released right away.  The disadvantage is that if\ninstances accumulate, so too will the accumulated method results.  They\ncan grow without bound. Thelru_cacheapproach works with methods that havehashablearguments.  It creates a reference to the instance unless special\nefforts are made to pass in weak references. The advantage of the least recently used algorithm is that the cache is\nbounded by the specifiedmaxsize.  The disadvantage is that instances\nare kept alive until they age out of the cache or until the cache is\ncleared. This example shows the various techniques: The above example assumes that thestation_idnever changes.  If the\nrelevant instance attributes are mutable, thecached_propertyapproach\ncan’t be made to work because it cannot detect changes to the\nattributes. To make thelru_cacheapproach work when thestation_idis mutable,\nthe class needs to define the__eq__()and__hash__()methods so that the cache can detect relevant attribute updates:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is a class?¶",
        "answer": "A class is the particular object type created by executing a class statement.\nClass objects are used as templates to create instance objects, which embody\nboth the data (attributes) and code (methods) specific to a datatype. A class can be based on one or more other classes, called its base class(es). It\nthen inherits the attributes and methods of its base classes. This allows an\nobject model to be successively refined by inheritance.  You might have a\ngenericMailboxclass that provides basic accessor methods for a mailbox,\nand subclasses such asMboxMailbox,MaildirMailbox,OutlookMailboxthat handle various specific mailbox formats.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is a method?¶",
        "answer": "A method is a function on some objectxthat you normally call asx.name(arguments...).  Methods are defined as functions inside the class\ndefinition:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is self?¶",
        "answer": "Self is merely a conventional name for the first argument of a method.  A method\ndefined asmeth(self,a,b,c)should be called asx.meth(a,b,c)for\nsome instancexof the class in which the definition occurs; the called\nmethod will think it is called asmeth(x,a,b,c). See alsoWhy must ‘self’ be used explicitly in method definitions and calls?.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I check if an object is an instance of a given class or of a subclass of it?¶",
        "answer": "Use the built-in functionisinstance(obj,cls).  You can\ncheck if an object\nis an instance of any of a number of classes by providing a tuple instead of a\nsingle class, e.g.isinstance(obj,(class1,class2,...)), and can also\ncheck whether an object is one of Python’s built-in types, e.g.isinstance(obj,str)orisinstance(obj,(int,float,complex)). Note thatisinstance()also checks for virtual inheritance from anabstract base class.  So, the test will returnTruefor a\nregistered class even if hasn’t directly or indirectly inherited from it.  To\ntest for “true inheritance”, scan theMROof the class: Note that most programs do not useisinstance()on user-defined classes\nvery often.  If you are developing the classes yourself, a more proper\nobject-oriented style is to define methods on the classes that encapsulate a\nparticular behaviour, instead of checking the object’s class and doing a\ndifferent thing based on what class it is.  For example, if you have a function\nthat does something: A better approach is to define asearch()method on all the classes and just\ncall it:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "What is delegation?¶",
        "answer": "Delegation is an object oriented technique (also called a design pattern).\nLet’s say you have an objectxand want to change the behaviour of just one\nof its methods.  You can create a new class that provides a new implementation\nof the method you’re interested in changing and delegates all other methods to\nthe corresponding method ofx. Python programmers can easily implement delegation.  For example, the following\nclass implements a class that behaves like a file but converts all written data\nto uppercase: Here theUpperOutclass redefines thewrite()method to convert the\nargument string to uppercase before calling the underlyingself._outfile.write()method.  All other methods are delegated to the\nunderlyingself._outfileobject.  The delegation is accomplished via the__getattr__()method; consultthe language referencefor more information about controlling attribute access. Note that for more general cases delegation can get trickier. When attributes\nmust be set as well as retrieved, the class must define a__setattr__()method too, and it must do so carefully.  The basic implementation of__setattr__()is roughly equivalent to the following: Most__setattr__()implementations must modifyself.__dict__to store\nlocal state for self without causing an infinite recursion.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I call a method defined in a base class from a derived class that extends it?¶",
        "answer": "Use the built-insuper()function: In the example,super()will automatically determine the instance from\nwhich it was called (theselfvalue), look up themethod resolution\norder(MRO) withtype(self).__mro__, and return the next in line afterDerivedin the MRO:Base.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I organize my code to make it easier to change the base class?¶",
        "answer": "You could assign the base class to an alias and derive from the alias.  Then all\nyou have to change is the value assigned to the alias.  Incidentally, this trick\nis also handy if you want to decide dynamically (e.g. depending on availability\nof resources) which base class to use.  Example:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I create static class data and static class methods?¶",
        "answer": "Both static data and static methods (in the sense of C++ or Java) are supported\nin Python. For static data, simply define a class attribute.  To assign a new value to the\nattribute, you have to explicitly use the class name in the assignment: c.countalso refers toC.countfor anycsuch thatisinstance(c,C)holds, unless overridden bycitself or by some class on the base-class\nsearch path fromc.__class__back toC. Caution: within a method of C, an assignment likeself.count=42creates a\nnew and unrelated instance named “count” inself’s own dict.  Rebinding of a\nclass-static data name must always specify the class whether inside a method or\nnot: Static methods are possible: However, a far more straightforward way to get the effect of a static method is\nvia a simple module-level function: If your code is structured so as to define one class (or tightly related class\nhierarchy) per module, this supplies the desired encapsulation.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I overload constructors (or methods) in Python?¶",
        "answer": "This answer actually applies to all methods, but the question usually comes up\nfirst in the context of constructors. In C++ you’d write In Python you have to write a single constructor that catches all cases using\ndefault arguments.  For example: This is not entirely equivalent, but close enough in practice. You could also try a variable-length argument list, e.g. The same approach works for all method definitions.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "I try to use __spam and I get an error about _SomeClassName__spam.¶",
        "answer": "Variable names with double leading underscores are “mangled” to provide a simple\nbut effective way to define class private variables.  Any identifier of the form__spam(at least two leading underscores, at most one trailing underscore)\nis textually replaced with_classname__spam, whereclassnameis the\ncurrent class name with any leading underscores stripped. The identifier can be used unchanged within the class, but to access it outside\nthe class, the mangled name must be used: In particular, this does not guarantee privacy since an outside user can still\ndeliberately access the private attribute; many Python programmers never bother\nto use private variable names at all. See also Theprivate name mangling specificationsfor details and special cases.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "My class defines __del__ but it is not called when I delete the object.¶",
        "answer": "There are several possible reasons for this. Thedelstatement does not necessarily call__del__()– it simply\ndecrements the object’s reference count, and if this reaches zero__del__()is called. If your data structures contain circular links (e.g. a tree where each child has\na parent reference and each parent has a list of children) the reference counts\nwill never go back to zero.  Once in a while Python runs an algorithm to detect\nsuch cycles, but the garbage collector might run some time after the last\nreference to your data structure vanishes, so your__del__()method may be\ncalled at an inconvenient and random time. This is inconvenient if you’re trying\nto reproduce a problem. Worse, the order in which object’s__del__()methods are executed is arbitrary.  You can rungc.collect()to force a\ncollection, but therearepathological cases where objects will never be\ncollected. Despite the cycle collector, it’s still a good idea to define an explicitclose()method on objects to be called whenever you’re done with them.  Theclose()method can then remove attributes that refer to subobjects.  Don’t\ncall__del__()directly –__del__()should callclose()andclose()should make sure that it can be called more than once for the same\nobject. Another way to avoid cyclical references is to use theweakrefmodule,\nwhich allows you to point to objects without incrementing their reference count.\nTree data structures, for instance, should use weak references for their parent\nand sibling references (if they need them!). Finally, if your__del__()method raises an exception, a warning message\nis printed tosys.stderr.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I get a list of all instances of a given class?¶",
        "answer": "Python does not keep track of all instances of a class (or of a built-in type).\nYou can program the class’s constructor to keep track of all instances by\nkeeping a list of weak references to each instance.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Why does the result ofid()appear to be not unique?¶",
        "answer": "Theid()builtin returns an integer that is guaranteed to be unique during\nthe lifetime of the object.  Since in CPython, this is the object’s memory\naddress, it happens frequently that after an object is deleted from memory, the\nnext freshly created object is allocated at the same position in memory.  This\nis illustrated by this example: The two ids belong to different integer objects that are created before, and\ndeleted immediately after execution of theid()call.  To be sure that\nobjects whose id you want to examine are still alive, create another reference\nto the object:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "When can I rely on identity tests with theisoperator?¶",
        "answer": "Theisoperator tests for object identity.  The testaisbis\nequivalent toid(a)==id(b). The most important property of an identity test is that an object is always\nidentical to itself,aisaalways returnsTrue.  Identity tests are\nusually faster than equality tests.  And unlike equality tests, identity tests\nare guaranteed to return a booleanTrueorFalse. However, identity tests canonlybe substituted for equality tests when\nobject identity is assured.  Generally, there are three circumstances where\nidentity is guaranteed: 1) Assignments create new names but do not change object identity.  After the\nassignmentnew=old, it is guaranteed thatnewisold. 2) Putting an object in a container that stores object references does not\nchange object identity.  After the list assignments[0]=x, it is\nguaranteed thats[0]isx. 3) If an object is a singleton, it means that only one instance of that object\ncan exist.  After the assignmentsa=Noneandb=None, it is\nguaranteed thataisbbecauseNoneis a singleton. In most other circumstances, identity tests are inadvisable and equality tests\nare preferred.  In particular, identity tests should not be used to check\nconstants such asintandstrwhich aren’t guaranteed to be\nsingletons: Likewise, new instances of mutable containers are never identical: In the standard library code, you will see several common patterns for\ncorrectly using identity tests: 1) As recommended byPEP 8, an identity test is the preferred way to check\nforNone.  This reads like plain English in code and avoids confusion with\nother objects that may have boolean values that evaluate to false. 2) Detecting optional arguments can be tricky whenNoneis a valid input\nvalue.  In those situations, you can create a singleton sentinel object\nguaranteed to be distinct from other objects.  For example, here is how\nto implement a method that behaves likedict.pop(): 3) Container implementations sometimes need to augment equality tests with\nidentity tests.  This prevents the code from being confused by objects such asfloat('NaN')that are not equal to themselves. For example, here is the implementation ofcollections.abc.Sequence.__contains__():",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can a subclass control what data is stored in an immutable instance?¶",
        "answer": "When subclassing an immutable type, override the__new__()method\ninstead of the__init__()method.  The latter only runsafteran\ninstance is created, which is too late to alter data in an immutable\ninstance. All of these immutable classes have a different signature than their\nparent class: The classes can be used like this:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I cache method calls?¶",
        "answer": "The two principal tools for caching methods arefunctools.cached_property()andfunctools.lru_cache().  The\nformer stores results at the instance level and the latter at the class\nlevel. Thecached_propertyapproach only works with methods that do not take\nany arguments.  It does not create a reference to the instance.  The\ncached method result will be kept only as long as the instance is alive. The advantage is that when an instance is no longer used, the cached\nmethod result will be released right away.  The disadvantage is that if\ninstances accumulate, so too will the accumulated method results.  They\ncan grow without bound. Thelru_cacheapproach works with methods that havehashablearguments.  It creates a reference to the instance unless special\nefforts are made to pass in weak references. The advantage of the least recently used algorithm is that the cache is\nbounded by the specifiedmaxsize.  The disadvantage is that instances\nare kept alive until they age out of the cache or until the cache is\ncleared. This example shows the various techniques: The above example assumes that thestation_idnever changes.  If the\nrelevant instance attributes are mutable, thecached_propertyapproach\ncan’t be made to work because it cannot detect changes to the\nattributes. To make thelru_cacheapproach work when thestation_idis mutable,\nthe class needs to define the__eq__()and__hash__()methods so that the cache can detect relevant attribute updates:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "Modules¶",
        "answer": "When a module is imported for the first time (or when the source file has\nchanged since the current compiled file was created) a.pycfile containing\nthe compiled code should be created in a__pycache__subdirectory of the\ndirectory containing the.pyfile.  The.pycfile will have a\nfilename that starts with the same name as the.pyfile, and ends with.pyc, with a middle component that depends on the particularpythonbinary that created it.  (SeePEP 3147for details.) One reason that a.pycfile may not be created is a permissions problem\nwith the directory containing the source file, meaning that the__pycache__subdirectory cannot be created. This can happen, for example, if you develop as\none user but run as another, such as if you are testing with a web server. Unless thePYTHONDONTWRITEBYTECODEenvironment variable is set,\ncreation of a .pyc file is automatic if you’re importing a module and Python\nhas the ability (permissions, free space, etc…) to create a__pycache__subdirectory and write the compiled module to that subdirectory. Running Python on a top level script is not considered an import and no.pycwill be created.  For example, if you have a top-level modulefoo.pythat imports another modulexyz.py, when you runfoo(by\ntypingpythonfoo.pyas a shell command), a.pycwill be created forxyzbecausexyzis imported, but no.pycfile will be created forfoosincefoo.pyisn’t being imported. If you need to create a.pycfile forfoo– that is, to create a.pycfile for a module that is not imported – you can, using thepy_compileandcompileallmodules. Thepy_compilemodule can manually compile any module.  One way is to use\nthecompile()function in that module interactively: This will write the.pycto a__pycache__subdirectory in the same\nlocation asfoo.py(or you can override that with the optional parametercfile). You can also automatically compile all files in a directory or directories using\nthecompileallmodule.  You can do it from the shell prompt by runningcompileall.pyand providing the path of a directory containing Python files\nto compile: A module can find out its own module name by looking at the predefined global\nvariable__name__.  If this has the value'__main__', the program is\nrunning as a script.  Many modules that are usually used by importing them also\nprovide a command-line interface or a self-test, and only execute this code\nafter checking__name__: Suppose you have the following modules: foo.py: bar.py: The problem is that the interpreter will perform the following steps: main importsfoo Empty globals forfooare created foois compiled and starts executing fooimportsbar Empty globals forbarare created baris compiled and starts executing barimportsfoo(which is a no-op since there already is a module namedfoo) The import mechanism tries to readfoo_varfromfooglobals, to setbar.foo_var=foo.foo_var The last step fails, because Python isn’t done with interpretingfooyet and\nthe global symbol dictionary forfoois still empty. The same thing happens when you useimportfoo, and then try to accessfoo.foo_varin global code. There are (at least) three possible workarounds for this problem. Guido van Rossum recommends avoiding all uses offrom<module>import...,\nand placing all code inside functions.  Initializations of global variables and\nclass variables should use constants or built-in functions only.  This means\neverything from an imported module is referenced as<module>.<name>. Jim Roskind suggests performing steps in the following order in each module: exports (globals, functions, and classes that don’t need imported base\nclasses) importstatements active code (including globals that are initialized from imported values). Van Rossum doesn’t like this approach much because the imports appear in a\nstrange place, but it does work. Matthias Urlichs recommends restructuring your code so that the recursive import\nis not necessary in the first place. These solutions are not mutually exclusive. Consider using the convenience functionimport_module()fromimportlibinstead: For reasons of efficiency as well as consistency, Python only reads the module\nfile on the first time a module is imported.  If it didn’t, in a program\nconsisting of many modules where each one imports the same basic module, the\nbasic module would be parsed and re-parsed many times.  To force re-reading of a\nchanged module, do this: Warning: this technique is not 100% fool-proof.  In particular, modules\ncontaining statements like will continue to work with the old version of the imported objects.  If the\nmodule contains class definitions, existing class instances willnotbe\nupdated to use the new class definition.  This can result in the following\nparadoxical behaviour: The nature of the problem is made clear if you print out the “identity” of the\nclass objects:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I create a .pyc file?¶",
        "answer": "When a module is imported for the first time (or when the source file has\nchanged since the current compiled file was created) a.pycfile containing\nthe compiled code should be created in a__pycache__subdirectory of the\ndirectory containing the.pyfile.  The.pycfile will have a\nfilename that starts with the same name as the.pyfile, and ends with.pyc, with a middle component that depends on the particularpythonbinary that created it.  (SeePEP 3147for details.) One reason that a.pycfile may not be created is a permissions problem\nwith the directory containing the source file, meaning that the__pycache__subdirectory cannot be created. This can happen, for example, if you develop as\none user but run as another, such as if you are testing with a web server. Unless thePYTHONDONTWRITEBYTECODEenvironment variable is set,\ncreation of a .pyc file is automatic if you’re importing a module and Python\nhas the ability (permissions, free space, etc…) to create a__pycache__subdirectory and write the compiled module to that subdirectory. Running Python on a top level script is not considered an import and no.pycwill be created.  For example, if you have a top-level modulefoo.pythat imports another modulexyz.py, when you runfoo(by\ntypingpythonfoo.pyas a shell command), a.pycwill be created forxyzbecausexyzis imported, but no.pycfile will be created forfoosincefoo.pyisn’t being imported. If you need to create a.pycfile forfoo– that is, to create a.pycfile for a module that is not imported – you can, using thepy_compileandcompileallmodules. Thepy_compilemodule can manually compile any module.  One way is to use\nthecompile()function in that module interactively: This will write the.pycto a__pycache__subdirectory in the same\nlocation asfoo.py(or you can override that with the optional parametercfile). You can also automatically compile all files in a directory or directories using\nthecompileallmodule.  You can do it from the shell prompt by runningcompileall.pyand providing the path of a directory containing Python files\nto compile:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How do I find the current module name?¶",
        "answer": "A module can find out its own module name by looking at the predefined global\nvariable__name__.  If this has the value'__main__', the program is\nrunning as a script.  Many modules that are usually used by importing them also\nprovide a command-line interface or a self-test, and only execute this code\nafter checking__name__:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "How can I have modules that mutually import each other?¶",
        "answer": "Suppose you have the following modules: foo.py: bar.py: The problem is that the interpreter will perform the following steps: main importsfoo Empty globals forfooare created foois compiled and starts executing fooimportsbar Empty globals forbarare created baris compiled and starts executing barimportsfoo(which is a no-op since there already is a module namedfoo) The import mechanism tries to readfoo_varfromfooglobals, to setbar.foo_var=foo.foo_var The last step fails, because Python isn’t done with interpretingfooyet and\nthe global symbol dictionary forfoois still empty. The same thing happens when you useimportfoo, and then try to accessfoo.foo_varin global code. There are (at least) three possible workarounds for this problem. Guido van Rossum recommends avoiding all uses offrom<module>import...,\nand placing all code inside functions.  Initializations of global variables and\nclass variables should use constants or built-in functions only.  This means\neverything from an imported module is referenced as<module>.<name>. Jim Roskind suggests performing steps in the following order in each module: exports (globals, functions, and classes that don’t need imported base\nclasses) importstatements active code (including globals that are initialized from imported values). Van Rossum doesn’t like this approach much because the imports appear in a\nstrange place, but it does work. Matthias Urlichs recommends restructuring your code so that the recursive import\nis not necessary in the first place. These solutions are not mutually exclusive.",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "__import__(‘x.y.z’) returns <module ‘x’>; how do I get z?¶",
        "answer": "Consider using the convenience functionimport_module()fromimportlibinstead:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "When I edit an imported module and reimport it, the changes don’t show up.  Why does this happen?¶",
        "answer": "For reasons of efficiency as well as consistency, Python only reads the module\nfile on the first time a module is imported.  If it didn’t, in a program\nconsisting of many modules where each one imports the same basic module, the\nbasic module would be parsed and re-parsed many times.  To force re-reading of a\nchanged module, do this: Warning: this technique is not 100% fool-proof.  In particular, modules\ncontaining statements like will continue to work with the old version of the imported objects.  If the\nmodule contains class definitions, existing class instances willnotbe\nupdated to use the new class definition.  This can result in the following\nparadoxical behaviour: The nature of the problem is made clear if you print out the “identity” of the\nclass objects:",
        "source": "data/html/programming-faq.html"
    },
    {
        "question": "General Library Questions¶",
        "answer": "Contents Library and Extension FAQ General Library Questions How do I find a module or application to perform task X? Where is the math.py (socket.py, regex.py, etc.) source file? How do I make a Python script executable on Unix? Is there a curses/termcap package for Python? Is there an equivalent to C’s onexit() in Python? Why don’t my signal handlers work? Common tasks How do I test a Python program or component? How do I create documentation from doc strings? How do I get a single keypress at a time? Threads How do I program using threads? None of my threads seem to run: why? How do I parcel out work among a bunch of worker threads? What kinds of global value mutation are thread-safe? Can’t we get rid of the Global Interpreter Lock? Input and Output How do I delete a file? (And other file questions…) How do I copy a file? How do I read (or write) binary data? I can’t seem to use os.read() on a pipe created with os.popen(); why? How do I access the serial (RS232) port? Why doesn’t closing sys.stdout (stdin, stderr) really close it? Network/Internet Programming What WWW tools are there for Python? How can I mimic CGI form submission (METHOD=POST)? What module should I use to help with generating HTML? How do I send mail from a Python script? How do I avoid blocking in the connect() method of a socket? Databases Are there any interfaces to database packages in Python? How do you implement persistent objects in Python? Mathematics and Numerics How do I generate random numbers in Python? Checkthe Library Referenceto see if there’s a relevant\nstandard library module.  (Eventually you’ll learn what’s in the standard\nlibrary and will be able to skip this step.) For third-party packages, search thePython Package Indexor tryGoogleor\nanother web search engine.  Searching for “Python” plus a keyword or two for\nyour topic of interest will usually find something helpful. If you can’t find a source file for a module it may be a built-in or\ndynamically loaded module implemented in C, C++ or other compiled language.\nIn this case you may not have the source file or it may be something likemathmodule.c, somewhere in a C source directory (not on the Python Path). There are (at least) three kinds of modules in Python: modules written in Python (.py); modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc); modules written in C and linked with the interpreter; to get a list of these,\ntype: You need to do two things: the script file’s mode must be executable and the\nfirst line must begin with#!followed by the path of the Python\ninterpreter. The first is done by executingchmod+xscriptfileor perhapschmod755scriptfile. The second can be done in a number of ways.  The most straightforward way is to\nwrite as the very first line of your file, using the pathname for where the Python\ninterpreter is installed on your platform. If you would like the script to be independent of where the Python interpreter\nlives, you can use theenvprogram.  Almost all Unix variants support\nthe following, assuming the Python interpreter is in a directory on the user’sPATH: Don’tdo this for CGI scripts.  ThePATHvariable for CGI scripts is\noften very minimal, so you need to use the actual absolute pathname of the\ninterpreter. Occasionally, a user’s environment is so full that the/usr/bin/envprogram fails; or there’s no env program at all.  In that case, you can try the\nfollowing hack (due to Alex Rezinsky): The minor disadvantage is that this defines the script’s __doc__ string.\nHowever, you can fix that by adding For Unix variants: The standard Python source distribution comes with a curses\nmodule in theModulessubdirectory, though it’s not compiled by default.\n(Note that this is not available in the Windows distribution – there is no\ncurses module for Windows.) Thecursesmodule supports basic curses features as well as many additional\nfunctions from ncurses and SYSV curses such as colour, alternative character set\nsupport, pads, and mouse support. This means the module isn’t compatible with\noperating systems that only have BSD curses, but there don’t seem to be any\ncurrently maintained OSes that fall into this category. Theatexitmodule provides a register function that is similar to C’sonexit(). The most common problem is that the signal handler is declared with the wrong\nargument list.  It is called as so it should be declared with two parameters: Python comes with two testing frameworks.  Thedoctestmodule finds\nexamples in the docstrings for a module and runs them, comparing the output with\nthe expected output given in the docstring. Theunittestmodule is a fancier testing framework modelled on Java and\nSmalltalk testing frameworks. To make testing easier, you should use good modular design in your program.\nYour program should have almost all functionality\nencapsulated in either functions or class methods – and this sometimes has the\nsurprising and delightful effect of making the program run faster (because local\nvariable accesses are faster than global accesses).  Furthermore the program\nshould avoid depending on mutating global variables, since this makes testing\nmuch more difficult to do. The “global main logic” of your program may be as simple as at the bottom of the main module of your program. Once your program is organized as a tractable collection of function and class\nbehaviours, you should write test functions that exercise the behaviours.  A\ntest suite that automates a sequence of tests can be associated with each module.\nThis sounds like a lot of work, but since Python is so terse and flexible it’s\nsurprisingly easy.  You can make coding much more pleasant and fun by writing\nyour test functions in parallel with the “production code”, since this makes it\neasy to find bugs and even design flaws earlier. “Support modules” that are not intended to be the main module of a program may\ninclude a self-test of the module. Even programs that interact with complex external interfaces may be tested when\nthe external interfaces are unavailable by using “fake” interfaces implemented\nin Python. Thepydocmodule can create HTML from the doc strings in your Python\nsource code.  An alternative for creating API documentation purely from\ndocstrings isepydoc.Sphinxcan also include docstring content. For Unix variants there are several solutions.  It’s straightforward to do this\nusing curses, but curses is a fairly large module to learn. Be sure to use thethreadingmodule and not the_threadmodule.\nThethreadingmodule builds convenient abstractions on top of the\nlow-level primitives provided by the_threadmodule. As soon as the main thread exits, all threads are killed.  Your main thread is\nrunning too quickly, giving the threads no time to do any work. A simple fix is to add a sleep to the end of the program that’s long enough for\nall the threads to finish: But now (on many platforms) the threads don’t run in parallel, but appear to run\nsequentially, one at a time!  The reason is that the OS thread scheduler doesn’t\nstart a new thread until the previous thread is blocked. A simple fix is to add a tiny sleep to the start of the run function: Instead of trying to guess a good delay value fortime.sleep(),\nit’s better to use some kind of semaphore mechanism.  One idea is to use thequeuemodule to create a queue object, let each thread append a token to\nthe queue when it finishes, and let the main thread read as many tokens from the\nqueue as there are threads. The easiest way is to use theconcurrent.futuresmodule,\nespecially theThreadPoolExecutorclass. Or, if you want fine control over the dispatching algorithm, you can write\nyour own logic manually.  Use thequeuemodule to create a queue\ncontaining a list of jobs.  TheQueueclass maintains a\nlist of objects and has a.put(obj)method that adds items to the queue and\na.get()method to return them.  The class will take care of the locking\nnecessary to ensure that each job is handed out exactly once. Here’s a trivial example: When run, this will produce the following output: Consult the module’s documentation for more details; theQueueclass provides a featureful interface. Aglobal interpreter lock(GIL) is used internally to ensure that only one\nthread runs in the Python VM at a time.  In general, Python offers to switch\namong threads only between bytecode instructions; how frequently it switches can\nbe set viasys.setswitchinterval().  Each bytecode instruction and\ntherefore all the C implementation code reached from each instruction is\ntherefore atomic from the point of view of a Python program. In theory, this means an exact accounting requires an exact understanding of the\nPVM bytecode implementation.  In practice, it means that operations on shared\nvariables of built-in data types (ints, lists, dicts, etc) that “look atomic”\nreally are. For example, the following operations are all atomic (L, L1, L2 are lists, D,\nD1, D2 are dicts, x, y are objects, i, j are ints): These aren’t: Operations that replace other objects may invoke those other objects’__del__()method when their reference count reaches zero, and that can\naffect things.  This is especially true for the mass updates to dictionaries and\nlists.  When in doubt, use a mutex! Theglobal interpreter lock(GIL) is often seen as a hindrance to Python’s\ndeployment on high-end multiprocessor server machines, because a multi-threaded\nPython program effectively only uses one CPU, due to the insistence that\n(almost) all Python code can only run while the GIL is held. Back in the days of Python 1.5, Greg Stein actually implemented a comprehensive\npatch set (the “free threading” patches) that removed the GIL and replaced it\nwith fine-grained locking.  Adam Olsen recently did a similar experiment\nin hispython-safethreadproject.  Unfortunately, both experiments exhibited a sharp drop in single-thread\nperformance (at least 30% slower), due to the amount of fine-grained locking\nnecessary to compensate for the removal of the GIL. This doesn’t mean that you can’t make good use of Python on multi-CPU machines!\nYou just have to be creative with dividing the work up between multipleprocessesrather than multiplethreads.  TheProcessPoolExecutorclass in the newconcurrent.futuresmodule provides an easy way of doing so; themultiprocessingmodule provides a lower-level API in case you want\nmore control over dispatching of tasks. Judicious use of C extensions will also help; if you use a C extension to\nperform a time-consuming task, the extension can release the GIL while the\nthread of execution is in the C code and allow other threads to get some work\ndone.  Some standard library modules such aszlibandhashlibalready do this. It has been suggested that the GIL should be a per-interpreter-state lock rather\nthan truly global; interpreters then wouldn’t be able to share objects.\nUnfortunately, this isn’t likely to happen either.  It would be a tremendous\namount of work, because many object implementations currently have global state.\nFor example, small integers and short strings are cached; these caches would\nhave to be moved to the interpreter state.  Other object types have their own\nfree list; these free lists would have to be moved to the interpreter state.\nAnd so on. And I doubt that it can even be done in finite time, because the same problem\nexists for 3rd party extensions.  It is likely that 3rd party extensions are\nbeing written at a faster rate than you can convert them to store all their\nglobal state in the interpreter state. And finally, once you have multiple interpreters not sharing any state, what\nhave you gained over running each interpreter in a separate process? Useos.remove(filename)oros.unlink(filename); for documentation, see\ntheosmodule.  The two functions are identical;unlink()is simply\nthe name of the Unix system call for this function. To remove a directory, useos.rmdir(); useos.mkdir()to create one.os.makedirs(path)will create any intermediate directories inpaththat\ndon’t exist.os.removedirs(path)will remove intermediate directories as\nlong as they’re empty; if you want to delete an entire directory tree and its\ncontents, useshutil.rmtree(). To rename a file, useos.rename(old_path,new_path). To truncate a file, open it usingf=open(filename,\"rb+\"), and usef.truncate(offset); offset defaults to the current seek position.  There’s\nalsoos.ftruncate(fd,offset)for files opened withos.open(), wherefdis the file descriptor (a small integer). Theshutilmodule also contains a number of functions to work on files\nincludingcopyfile(),copytree(), andrmtree(). Theshutilmodule contains acopyfile()function.\nNote that on Windows NTFS volumes, it does not copyalternate data streamsnorresource forkson macOS HFS+ volumes, though both are now rarely used.\nIt also doesn’t copy file permissions and metadata, though usingshutil.copy2()instead will preserve most (though not all) of it. To read or write complex binary data formats, it’s best to use thestructmodule.  It allows you to take a string containing binary data (usually numbers)\nand convert it to Python objects; and vice versa. For example, the following code reads two 2-byte integers and one 4-byte integer\nin big-endian format from a file: The ‘>’ in the format string forces big-endian data; the letter ‘h’ reads one\n“short integer” (2 bytes), and ‘l’ reads one “long integer” (4 bytes) from the\nstring. For data that is more regular (e.g. a homogeneous list of ints or floats),\nyou can also use thearraymodule. Note To read and write binary data, it is mandatory to open the file in\nbinary mode (here, passing\"rb\"toopen()).  If you use\"r\"instead (the default), the file will be open in text mode\nandf.read()will returnstrobjects rather thanbytesobjects. os.read()is a low-level function which takes a file descriptor, a small\ninteger representing the opened file.os.popen()creates a high-level\nfile object, the same type returned by the built-inopen()function.\nThus, to readnbytes from a pipepcreated withos.popen(), you need to\nusep.read(n). For Win32, OSX, Linux, BSD, Jython, IronPython: pyserial pyserial For Unix, see a Usenet post by Mitch Chapman: https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com Pythonfile objectsare a high-level layer of\nabstraction on low-level C file descriptors. For most file objects you create in Python via the built-inopen()function,f.close()marks the Python file object as being closed from\nPython’s point of view, and also arranges to close the underlying C file\ndescriptor.  This also happens automatically inf’s destructor, whenfbecomes garbage. But stdin, stdout and stderr are treated specially by Python, because of the\nspecial status also given to them by C.  Runningsys.stdout.close()marks\nthe Python-level file object as being closed, but doesnotclose the\nassociated C file descriptor. To close the underlying C file descriptor for one of these three, you should\nfirst be sure that’s what you really want to do (e.g., you may confuse\nextension modules trying to do I/O).  If it is, useos.close(): Or you can use the numeric constants 0, 1 and 2, respectively. See the chapters titledInternet Protocols and SupportandInternet Data Handlingin the Library\nReference Manual.  Python has many modules that will help you build server-side\nand client-side web systems. A summary of available frameworks is maintained by Paul Boddie athttps://wiki.python.org/moin/WebProgramming. Cameron Laird maintains a useful set of pages about Python web technologies athttps://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp.lang.python/web_python. I would like to retrieve web pages that are the result of POSTing a form. Is\nthere existing code that would let me do this easily? Yes. Here’s a simple example that usesurllib.request: Note that in general for percent-encoded POST operations, query strings must be\nquoted usingurllib.parse.urlencode().  For example, to sendname=GuySteele,Jr.: See also HOWTO Fetch Internet Resources Using The urllib Packagefor extensive examples. You can find a collection of useful links on theWeb Programming wiki page. Use the standard library modulesmtplib. Here’s a very simple interactive mail sender that uses it.  This method will\nwork on any host that supports an SMTP listener. A Unix-only alternative uses sendmail.  The location of the sendmail program\nvaries between systems; sometimes it is/usr/lib/sendmail, sometimes/usr/sbin/sendmail.  The sendmail manual page will help you out.  Here’s\nsome sample code: Theselectmodule is commonly used to help with asynchronous I/O on\nsockets. To prevent the TCP connect from blocking, you can set the socket to non-blocking\nmode.  Then when you do theconnect(),\nyou will either connect immediately\n(unlikely) or get an exception that contains the error number as.errno.errno.EINPROGRESSindicates that the connection is in progress, but hasn’t\nfinished yet.  Different OSes will return different values, so you’re going to\nhave to check what’s returned on your system. You can use theconnect_ex()method\nto avoid creating an exception.\nIt will just return the errno value.\nTo poll, you can callconnect_ex()again later\n–0orerrno.EISCONNindicate that you’re connected – or you can pass this\nsocket toselect.select()to check if it’s writable. Note Theasynciomodule provides a general purpose single-threaded and\nconcurrent asynchronous library, which can be used for writing non-blocking\nnetwork code.\nThe third-partyTwistedlibrary is\na popular and feature-rich alternative. Yes. Interfaces to disk-based hashes such asDBMandGDBMare also included with standard Python.  There is also thesqlite3module, which provides a lightweight disk-based relational\ndatabase. Support for most relational databases is available.  See theDatabaseProgramming wiki pagefor details. Thepicklelibrary module solves this in a very general way (though you\nstill can’t store things like open files, sockets or windows), and theshelvelibrary module uses pickle and (g)dbm to create persistent\nmappings containing arbitrary Python objects. The standard modulerandomimplements a random number generator.  Usage\nis simple: This returns a random floating-point number in the range [0, 1). There are also many other specialized generators in this module, such as: randrange(a,b)chooses an integer in the range [a, b). uniform(a,b)chooses a floating-point number in the range [a, b). normalvariate(mean,sdev)samples the normal (Gaussian) distribution. Some higher-level functions operate on sequences directly, such as: choice(S)chooses a random element from a given sequence. shuffle(L)shuffles a list in-place, i.e. permutes it randomly. There’s also aRandomclass you can instantiate to create independent\nmultiple random number generators.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "General Library Questions¶",
        "answer": "Checkthe Library Referenceto see if there’s a relevant\nstandard library module.  (Eventually you’ll learn what’s in the standard\nlibrary and will be able to skip this step.) For third-party packages, search thePython Package Indexor tryGoogleor\nanother web search engine.  Searching for “Python” plus a keyword or two for\nyour topic of interest will usually find something helpful. If you can’t find a source file for a module it may be a built-in or\ndynamically loaded module implemented in C, C++ or other compiled language.\nIn this case you may not have the source file or it may be something likemathmodule.c, somewhere in a C source directory (not on the Python Path). There are (at least) three kinds of modules in Python: modules written in Python (.py); modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc); modules written in C and linked with the interpreter; to get a list of these,\ntype: You need to do two things: the script file’s mode must be executable and the\nfirst line must begin with#!followed by the path of the Python\ninterpreter. The first is done by executingchmod+xscriptfileor perhapschmod755scriptfile. The second can be done in a number of ways.  The most straightforward way is to\nwrite as the very first line of your file, using the pathname for where the Python\ninterpreter is installed on your platform. If you would like the script to be independent of where the Python interpreter\nlives, you can use theenvprogram.  Almost all Unix variants support\nthe following, assuming the Python interpreter is in a directory on the user’sPATH: Don’tdo this for CGI scripts.  ThePATHvariable for CGI scripts is\noften very minimal, so you need to use the actual absolute pathname of the\ninterpreter. Occasionally, a user’s environment is so full that the/usr/bin/envprogram fails; or there’s no env program at all.  In that case, you can try the\nfollowing hack (due to Alex Rezinsky): The minor disadvantage is that this defines the script’s __doc__ string.\nHowever, you can fix that by adding For Unix variants: The standard Python source distribution comes with a curses\nmodule in theModulessubdirectory, though it’s not compiled by default.\n(Note that this is not available in the Windows distribution – there is no\ncurses module for Windows.) Thecursesmodule supports basic curses features as well as many additional\nfunctions from ncurses and SYSV curses such as colour, alternative character set\nsupport, pads, and mouse support. This means the module isn’t compatible with\noperating systems that only have BSD curses, but there don’t seem to be any\ncurrently maintained OSes that fall into this category. Theatexitmodule provides a register function that is similar to C’sonexit(). The most common problem is that the signal handler is declared with the wrong\nargument list.  It is called as so it should be declared with two parameters:",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I find a module or application to perform task X?¶",
        "answer": "Checkthe Library Referenceto see if there’s a relevant\nstandard library module.  (Eventually you’ll learn what’s in the standard\nlibrary and will be able to skip this step.) For third-party packages, search thePython Package Indexor tryGoogleor\nanother web search engine.  Searching for “Python” plus a keyword or two for\nyour topic of interest will usually find something helpful.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Where is the math.py (socket.py, regex.py, etc.) source file?¶",
        "answer": "If you can’t find a source file for a module it may be a built-in or\ndynamically loaded module implemented in C, C++ or other compiled language.\nIn this case you may not have the source file or it may be something likemathmodule.c, somewhere in a C source directory (not on the Python Path). There are (at least) three kinds of modules in Python: modules written in Python (.py); modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc); modules written in C and linked with the interpreter; to get a list of these,\ntype:",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I make a Python script executable on Unix?¶",
        "answer": "You need to do two things: the script file’s mode must be executable and the\nfirst line must begin with#!followed by the path of the Python\ninterpreter. The first is done by executingchmod+xscriptfileor perhapschmod755scriptfile. The second can be done in a number of ways.  The most straightforward way is to\nwrite as the very first line of your file, using the pathname for where the Python\ninterpreter is installed on your platform. If you would like the script to be independent of where the Python interpreter\nlives, you can use theenvprogram.  Almost all Unix variants support\nthe following, assuming the Python interpreter is in a directory on the user’sPATH: Don’tdo this for CGI scripts.  ThePATHvariable for CGI scripts is\noften very minimal, so you need to use the actual absolute pathname of the\ninterpreter. Occasionally, a user’s environment is so full that the/usr/bin/envprogram fails; or there’s no env program at all.  In that case, you can try the\nfollowing hack (due to Alex Rezinsky): The minor disadvantage is that this defines the script’s __doc__ string.\nHowever, you can fix that by adding",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Is there a curses/termcap package for Python?¶",
        "answer": "For Unix variants: The standard Python source distribution comes with a curses\nmodule in theModulessubdirectory, though it’s not compiled by default.\n(Note that this is not available in the Windows distribution – there is no\ncurses module for Windows.) Thecursesmodule supports basic curses features as well as many additional\nfunctions from ncurses and SYSV curses such as colour, alternative character set\nsupport, pads, and mouse support. This means the module isn’t compatible with\noperating systems that only have BSD curses, but there don’t seem to be any\ncurrently maintained OSes that fall into this category.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Is there an equivalent to C’s onexit() in Python?¶",
        "answer": "Theatexitmodule provides a register function that is similar to C’sonexit().",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Why don’t my signal handlers work?¶",
        "answer": "The most common problem is that the signal handler is declared with the wrong\nargument list.  It is called as so it should be declared with two parameters:",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Common tasks¶",
        "answer": "Python comes with two testing frameworks.  Thedoctestmodule finds\nexamples in the docstrings for a module and runs them, comparing the output with\nthe expected output given in the docstring. Theunittestmodule is a fancier testing framework modelled on Java and\nSmalltalk testing frameworks. To make testing easier, you should use good modular design in your program.\nYour program should have almost all functionality\nencapsulated in either functions or class methods – and this sometimes has the\nsurprising and delightful effect of making the program run faster (because local\nvariable accesses are faster than global accesses).  Furthermore the program\nshould avoid depending on mutating global variables, since this makes testing\nmuch more difficult to do. The “global main logic” of your program may be as simple as at the bottom of the main module of your program. Once your program is organized as a tractable collection of function and class\nbehaviours, you should write test functions that exercise the behaviours.  A\ntest suite that automates a sequence of tests can be associated with each module.\nThis sounds like a lot of work, but since Python is so terse and flexible it’s\nsurprisingly easy.  You can make coding much more pleasant and fun by writing\nyour test functions in parallel with the “production code”, since this makes it\neasy to find bugs and even design flaws earlier. “Support modules” that are not intended to be the main module of a program may\ninclude a self-test of the module. Even programs that interact with complex external interfaces may be tested when\nthe external interfaces are unavailable by using “fake” interfaces implemented\nin Python. Thepydocmodule can create HTML from the doc strings in your Python\nsource code.  An alternative for creating API documentation purely from\ndocstrings isepydoc.Sphinxcan also include docstring content. For Unix variants there are several solutions.  It’s straightforward to do this\nusing curses, but curses is a fairly large module to learn.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I test a Python program or component?¶",
        "answer": "Python comes with two testing frameworks.  Thedoctestmodule finds\nexamples in the docstrings for a module and runs them, comparing the output with\nthe expected output given in the docstring. Theunittestmodule is a fancier testing framework modelled on Java and\nSmalltalk testing frameworks. To make testing easier, you should use good modular design in your program.\nYour program should have almost all functionality\nencapsulated in either functions or class methods – and this sometimes has the\nsurprising and delightful effect of making the program run faster (because local\nvariable accesses are faster than global accesses).  Furthermore the program\nshould avoid depending on mutating global variables, since this makes testing\nmuch more difficult to do. The “global main logic” of your program may be as simple as at the bottom of the main module of your program. Once your program is organized as a tractable collection of function and class\nbehaviours, you should write test functions that exercise the behaviours.  A\ntest suite that automates a sequence of tests can be associated with each module.\nThis sounds like a lot of work, but since Python is so terse and flexible it’s\nsurprisingly easy.  You can make coding much more pleasant and fun by writing\nyour test functions in parallel with the “production code”, since this makes it\neasy to find bugs and even design flaws earlier. “Support modules” that are not intended to be the main module of a program may\ninclude a self-test of the module. Even programs that interact with complex external interfaces may be tested when\nthe external interfaces are unavailable by using “fake” interfaces implemented\nin Python.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I create documentation from doc strings?¶",
        "answer": "Thepydocmodule can create HTML from the doc strings in your Python\nsource code.  An alternative for creating API documentation purely from\ndocstrings isepydoc.Sphinxcan also include docstring content.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I get a single keypress at a time?¶",
        "answer": "For Unix variants there are several solutions.  It’s straightforward to do this\nusing curses, but curses is a fairly large module to learn.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Threads¶",
        "answer": "Be sure to use thethreadingmodule and not the_threadmodule.\nThethreadingmodule builds convenient abstractions on top of the\nlow-level primitives provided by the_threadmodule. As soon as the main thread exits, all threads are killed.  Your main thread is\nrunning too quickly, giving the threads no time to do any work. A simple fix is to add a sleep to the end of the program that’s long enough for\nall the threads to finish: But now (on many platforms) the threads don’t run in parallel, but appear to run\nsequentially, one at a time!  The reason is that the OS thread scheduler doesn’t\nstart a new thread until the previous thread is blocked. A simple fix is to add a tiny sleep to the start of the run function: Instead of trying to guess a good delay value fortime.sleep(),\nit’s better to use some kind of semaphore mechanism.  One idea is to use thequeuemodule to create a queue object, let each thread append a token to\nthe queue when it finishes, and let the main thread read as many tokens from the\nqueue as there are threads. The easiest way is to use theconcurrent.futuresmodule,\nespecially theThreadPoolExecutorclass. Or, if you want fine control over the dispatching algorithm, you can write\nyour own logic manually.  Use thequeuemodule to create a queue\ncontaining a list of jobs.  TheQueueclass maintains a\nlist of objects and has a.put(obj)method that adds items to the queue and\na.get()method to return them.  The class will take care of the locking\nnecessary to ensure that each job is handed out exactly once. Here’s a trivial example: When run, this will produce the following output: Consult the module’s documentation for more details; theQueueclass provides a featureful interface. Aglobal interpreter lock(GIL) is used internally to ensure that only one\nthread runs in the Python VM at a time.  In general, Python offers to switch\namong threads only between bytecode instructions; how frequently it switches can\nbe set viasys.setswitchinterval().  Each bytecode instruction and\ntherefore all the C implementation code reached from each instruction is\ntherefore atomic from the point of view of a Python program. In theory, this means an exact accounting requires an exact understanding of the\nPVM bytecode implementation.  In practice, it means that operations on shared\nvariables of built-in data types (ints, lists, dicts, etc) that “look atomic”\nreally are. For example, the following operations are all atomic (L, L1, L2 are lists, D,\nD1, D2 are dicts, x, y are objects, i, j are ints): These aren’t: Operations that replace other objects may invoke those other objects’__del__()method when their reference count reaches zero, and that can\naffect things.  This is especially true for the mass updates to dictionaries and\nlists.  When in doubt, use a mutex! Theglobal interpreter lock(GIL) is often seen as a hindrance to Python’s\ndeployment on high-end multiprocessor server machines, because a multi-threaded\nPython program effectively only uses one CPU, due to the insistence that\n(almost) all Python code can only run while the GIL is held. Back in the days of Python 1.5, Greg Stein actually implemented a comprehensive\npatch set (the “free threading” patches) that removed the GIL and replaced it\nwith fine-grained locking.  Adam Olsen recently did a similar experiment\nin hispython-safethreadproject.  Unfortunately, both experiments exhibited a sharp drop in single-thread\nperformance (at least 30% slower), due to the amount of fine-grained locking\nnecessary to compensate for the removal of the GIL. This doesn’t mean that you can’t make good use of Python on multi-CPU machines!\nYou just have to be creative with dividing the work up between multipleprocessesrather than multiplethreads.  TheProcessPoolExecutorclass in the newconcurrent.futuresmodule provides an easy way of doing so; themultiprocessingmodule provides a lower-level API in case you want\nmore control over dispatching of tasks. Judicious use of C extensions will also help; if you use a C extension to\nperform a time-consuming task, the extension can release the GIL while the\nthread of execution is in the C code and allow other threads to get some work\ndone.  Some standard library modules such aszlibandhashlibalready do this. It has been suggested that the GIL should be a per-interpreter-state lock rather\nthan truly global; interpreters then wouldn’t be able to share objects.\nUnfortunately, this isn’t likely to happen either.  It would be a tremendous\namount of work, because many object implementations currently have global state.\nFor example, small integers and short strings are cached; these caches would\nhave to be moved to the interpreter state.  Other object types have their own\nfree list; these free lists would have to be moved to the interpreter state.\nAnd so on. And I doubt that it can even be done in finite time, because the same problem\nexists for 3rd party extensions.  It is likely that 3rd party extensions are\nbeing written at a faster rate than you can convert them to store all their\nglobal state in the interpreter state. And finally, once you have multiple interpreters not sharing any state, what\nhave you gained over running each interpreter in a separate process?",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I program using threads?¶",
        "answer": "Be sure to use thethreadingmodule and not the_threadmodule.\nThethreadingmodule builds convenient abstractions on top of the\nlow-level primitives provided by the_threadmodule.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "None of my threads seem to run: why?¶",
        "answer": "As soon as the main thread exits, all threads are killed.  Your main thread is\nrunning too quickly, giving the threads no time to do any work. A simple fix is to add a sleep to the end of the program that’s long enough for\nall the threads to finish: But now (on many platforms) the threads don’t run in parallel, but appear to run\nsequentially, one at a time!  The reason is that the OS thread scheduler doesn’t\nstart a new thread until the previous thread is blocked. A simple fix is to add a tiny sleep to the start of the run function: Instead of trying to guess a good delay value fortime.sleep(),\nit’s better to use some kind of semaphore mechanism.  One idea is to use thequeuemodule to create a queue object, let each thread append a token to\nthe queue when it finishes, and let the main thread read as many tokens from the\nqueue as there are threads.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I parcel out work among a bunch of worker threads?¶",
        "answer": "The easiest way is to use theconcurrent.futuresmodule,\nespecially theThreadPoolExecutorclass. Or, if you want fine control over the dispatching algorithm, you can write\nyour own logic manually.  Use thequeuemodule to create a queue\ncontaining a list of jobs.  TheQueueclass maintains a\nlist of objects and has a.put(obj)method that adds items to the queue and\na.get()method to return them.  The class will take care of the locking\nnecessary to ensure that each job is handed out exactly once. Here’s a trivial example: When run, this will produce the following output: Consult the module’s documentation for more details; theQueueclass provides a featureful interface.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "What kinds of global value mutation are thread-safe?¶",
        "answer": "Aglobal interpreter lock(GIL) is used internally to ensure that only one\nthread runs in the Python VM at a time.  In general, Python offers to switch\namong threads only between bytecode instructions; how frequently it switches can\nbe set viasys.setswitchinterval().  Each bytecode instruction and\ntherefore all the C implementation code reached from each instruction is\ntherefore atomic from the point of view of a Python program. In theory, this means an exact accounting requires an exact understanding of the\nPVM bytecode implementation.  In practice, it means that operations on shared\nvariables of built-in data types (ints, lists, dicts, etc) that “look atomic”\nreally are. For example, the following operations are all atomic (L, L1, L2 are lists, D,\nD1, D2 are dicts, x, y are objects, i, j are ints): These aren’t: Operations that replace other objects may invoke those other objects’__del__()method when their reference count reaches zero, and that can\naffect things.  This is especially true for the mass updates to dictionaries and\nlists.  When in doubt, use a mutex!",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Can’t we get rid of the Global Interpreter Lock?¶",
        "answer": "Theglobal interpreter lock(GIL) is often seen as a hindrance to Python’s\ndeployment on high-end multiprocessor server machines, because a multi-threaded\nPython program effectively only uses one CPU, due to the insistence that\n(almost) all Python code can only run while the GIL is held. Back in the days of Python 1.5, Greg Stein actually implemented a comprehensive\npatch set (the “free threading” patches) that removed the GIL and replaced it\nwith fine-grained locking.  Adam Olsen recently did a similar experiment\nin hispython-safethreadproject.  Unfortunately, both experiments exhibited a sharp drop in single-thread\nperformance (at least 30% slower), due to the amount of fine-grained locking\nnecessary to compensate for the removal of the GIL. This doesn’t mean that you can’t make good use of Python on multi-CPU machines!\nYou just have to be creative with dividing the work up between multipleprocessesrather than multiplethreads.  TheProcessPoolExecutorclass in the newconcurrent.futuresmodule provides an easy way of doing so; themultiprocessingmodule provides a lower-level API in case you want\nmore control over dispatching of tasks. Judicious use of C extensions will also help; if you use a C extension to\nperform a time-consuming task, the extension can release the GIL while the\nthread of execution is in the C code and allow other threads to get some work\ndone.  Some standard library modules such aszlibandhashlibalready do this. It has been suggested that the GIL should be a per-interpreter-state lock rather\nthan truly global; interpreters then wouldn’t be able to share objects.\nUnfortunately, this isn’t likely to happen either.  It would be a tremendous\namount of work, because many object implementations currently have global state.\nFor example, small integers and short strings are cached; these caches would\nhave to be moved to the interpreter state.  Other object types have their own\nfree list; these free lists would have to be moved to the interpreter state.\nAnd so on. And I doubt that it can even be done in finite time, because the same problem\nexists for 3rd party extensions.  It is likely that 3rd party extensions are\nbeing written at a faster rate than you can convert them to store all their\nglobal state in the interpreter state. And finally, once you have multiple interpreters not sharing any state, what\nhave you gained over running each interpreter in a separate process?",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Input and Output¶",
        "answer": "Useos.remove(filename)oros.unlink(filename); for documentation, see\ntheosmodule.  The two functions are identical;unlink()is simply\nthe name of the Unix system call for this function. To remove a directory, useos.rmdir(); useos.mkdir()to create one.os.makedirs(path)will create any intermediate directories inpaththat\ndon’t exist.os.removedirs(path)will remove intermediate directories as\nlong as they’re empty; if you want to delete an entire directory tree and its\ncontents, useshutil.rmtree(). To rename a file, useos.rename(old_path,new_path). To truncate a file, open it usingf=open(filename,\"rb+\"), and usef.truncate(offset); offset defaults to the current seek position.  There’s\nalsoos.ftruncate(fd,offset)for files opened withos.open(), wherefdis the file descriptor (a small integer). Theshutilmodule also contains a number of functions to work on files\nincludingcopyfile(),copytree(), andrmtree(). Theshutilmodule contains acopyfile()function.\nNote that on Windows NTFS volumes, it does not copyalternate data streamsnorresource forkson macOS HFS+ volumes, though both are now rarely used.\nIt also doesn’t copy file permissions and metadata, though usingshutil.copy2()instead will preserve most (though not all) of it. To read or write complex binary data formats, it’s best to use thestructmodule.  It allows you to take a string containing binary data (usually numbers)\nand convert it to Python objects; and vice versa. For example, the following code reads two 2-byte integers and one 4-byte integer\nin big-endian format from a file: The ‘>’ in the format string forces big-endian data; the letter ‘h’ reads one\n“short integer” (2 bytes), and ‘l’ reads one “long integer” (4 bytes) from the\nstring. For data that is more regular (e.g. a homogeneous list of ints or floats),\nyou can also use thearraymodule. Note To read and write binary data, it is mandatory to open the file in\nbinary mode (here, passing\"rb\"toopen()).  If you use\"r\"instead (the default), the file will be open in text mode\nandf.read()will returnstrobjects rather thanbytesobjects. os.read()is a low-level function which takes a file descriptor, a small\ninteger representing the opened file.os.popen()creates a high-level\nfile object, the same type returned by the built-inopen()function.\nThus, to readnbytes from a pipepcreated withos.popen(), you need to\nusep.read(n). For Win32, OSX, Linux, BSD, Jython, IronPython: pyserial pyserial For Unix, see a Usenet post by Mitch Chapman: https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com Pythonfile objectsare a high-level layer of\nabstraction on low-level C file descriptors. For most file objects you create in Python via the built-inopen()function,f.close()marks the Python file object as being closed from\nPython’s point of view, and also arranges to close the underlying C file\ndescriptor.  This also happens automatically inf’s destructor, whenfbecomes garbage. But stdin, stdout and stderr are treated specially by Python, because of the\nspecial status also given to them by C.  Runningsys.stdout.close()marks\nthe Python-level file object as being closed, but doesnotclose the\nassociated C file descriptor. To close the underlying C file descriptor for one of these three, you should\nfirst be sure that’s what you really want to do (e.g., you may confuse\nextension modules trying to do I/O).  If it is, useos.close(): Or you can use the numeric constants 0, 1 and 2, respectively.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I delete a file? (And other file questions…)¶",
        "answer": "Useos.remove(filename)oros.unlink(filename); for documentation, see\ntheosmodule.  The two functions are identical;unlink()is simply\nthe name of the Unix system call for this function. To remove a directory, useos.rmdir(); useos.mkdir()to create one.os.makedirs(path)will create any intermediate directories inpaththat\ndon’t exist.os.removedirs(path)will remove intermediate directories as\nlong as they’re empty; if you want to delete an entire directory tree and its\ncontents, useshutil.rmtree(). To rename a file, useos.rename(old_path,new_path). To truncate a file, open it usingf=open(filename,\"rb+\"), and usef.truncate(offset); offset defaults to the current seek position.  There’s\nalsoos.ftruncate(fd,offset)for files opened withos.open(), wherefdis the file descriptor (a small integer). Theshutilmodule also contains a number of functions to work on files\nincludingcopyfile(),copytree(), andrmtree().",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I copy a file?¶",
        "answer": "Theshutilmodule contains acopyfile()function.\nNote that on Windows NTFS volumes, it does not copyalternate data streamsnorresource forkson macOS HFS+ volumes, though both are now rarely used.\nIt also doesn’t copy file permissions and metadata, though usingshutil.copy2()instead will preserve most (though not all) of it.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I read (or write) binary data?¶",
        "answer": "To read or write complex binary data formats, it’s best to use thestructmodule.  It allows you to take a string containing binary data (usually numbers)\nand convert it to Python objects; and vice versa. For example, the following code reads two 2-byte integers and one 4-byte integer\nin big-endian format from a file: The ‘>’ in the format string forces big-endian data; the letter ‘h’ reads one\n“short integer” (2 bytes), and ‘l’ reads one “long integer” (4 bytes) from the\nstring. For data that is more regular (e.g. a homogeneous list of ints or floats),\nyou can also use thearraymodule. Note To read and write binary data, it is mandatory to open the file in\nbinary mode (here, passing\"rb\"toopen()).  If you use\"r\"instead (the default), the file will be open in text mode\nandf.read()will returnstrobjects rather thanbytesobjects.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "I can’t seem to use os.read() on a pipe created with os.popen(); why?¶",
        "answer": "os.read()is a low-level function which takes a file descriptor, a small\ninteger representing the opened file.os.popen()creates a high-level\nfile object, the same type returned by the built-inopen()function.\nThus, to readnbytes from a pipepcreated withos.popen(), you need to\nusep.read(n).",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I access the serial (RS232) port?¶",
        "answer": "For Win32, OSX, Linux, BSD, Jython, IronPython: pyserial pyserial For Unix, see a Usenet post by Mitch Chapman: https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Why doesn’t closing sys.stdout (stdin, stderr) really close it?¶",
        "answer": "Pythonfile objectsare a high-level layer of\nabstraction on low-level C file descriptors. For most file objects you create in Python via the built-inopen()function,f.close()marks the Python file object as being closed from\nPython’s point of view, and also arranges to close the underlying C file\ndescriptor.  This also happens automatically inf’s destructor, whenfbecomes garbage. But stdin, stdout and stderr are treated specially by Python, because of the\nspecial status also given to them by C.  Runningsys.stdout.close()marks\nthe Python-level file object as being closed, but doesnotclose the\nassociated C file descriptor. To close the underlying C file descriptor for one of these three, you should\nfirst be sure that’s what you really want to do (e.g., you may confuse\nextension modules trying to do I/O).  If it is, useos.close(): Or you can use the numeric constants 0, 1 and 2, respectively.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Network/Internet Programming¶",
        "answer": "See the chapters titledInternet Protocols and SupportandInternet Data Handlingin the Library\nReference Manual.  Python has many modules that will help you build server-side\nand client-side web systems. A summary of available frameworks is maintained by Paul Boddie athttps://wiki.python.org/moin/WebProgramming. Cameron Laird maintains a useful set of pages about Python web technologies athttps://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp.lang.python/web_python. I would like to retrieve web pages that are the result of POSTing a form. Is\nthere existing code that would let me do this easily? Yes. Here’s a simple example that usesurllib.request: Note that in general for percent-encoded POST operations, query strings must be\nquoted usingurllib.parse.urlencode().  For example, to sendname=GuySteele,Jr.: See also HOWTO Fetch Internet Resources Using The urllib Packagefor extensive examples. You can find a collection of useful links on theWeb Programming wiki page. Use the standard library modulesmtplib. Here’s a very simple interactive mail sender that uses it.  This method will\nwork on any host that supports an SMTP listener. A Unix-only alternative uses sendmail.  The location of the sendmail program\nvaries between systems; sometimes it is/usr/lib/sendmail, sometimes/usr/sbin/sendmail.  The sendmail manual page will help you out.  Here’s\nsome sample code: Theselectmodule is commonly used to help with asynchronous I/O on\nsockets. To prevent the TCP connect from blocking, you can set the socket to non-blocking\nmode.  Then when you do theconnect(),\nyou will either connect immediately\n(unlikely) or get an exception that contains the error number as.errno.errno.EINPROGRESSindicates that the connection is in progress, but hasn’t\nfinished yet.  Different OSes will return different values, so you’re going to\nhave to check what’s returned on your system. You can use theconnect_ex()method\nto avoid creating an exception.\nIt will just return the errno value.\nTo poll, you can callconnect_ex()again later\n–0orerrno.EISCONNindicate that you’re connected – or you can pass this\nsocket toselect.select()to check if it’s writable. Note Theasynciomodule provides a general purpose single-threaded and\nconcurrent asynchronous library, which can be used for writing non-blocking\nnetwork code.\nThe third-partyTwistedlibrary is\na popular and feature-rich alternative.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "What WWW tools are there for Python?¶",
        "answer": "See the chapters titledInternet Protocols and SupportandInternet Data Handlingin the Library\nReference Manual.  Python has many modules that will help you build server-side\nand client-side web systems. A summary of available frameworks is maintained by Paul Boddie athttps://wiki.python.org/moin/WebProgramming. Cameron Laird maintains a useful set of pages about Python web technologies athttps://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp.lang.python/web_python.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How can I mimic CGI form submission (METHOD=POST)?¶",
        "answer": "I would like to retrieve web pages that are the result of POSTing a form. Is\nthere existing code that would let me do this easily? Yes. Here’s a simple example that usesurllib.request: Note that in general for percent-encoded POST operations, query strings must be\nquoted usingurllib.parse.urlencode().  For example, to sendname=GuySteele,Jr.: See also HOWTO Fetch Internet Resources Using The urllib Packagefor extensive examples.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "What module should I use to help with generating HTML?¶",
        "answer": "You can find a collection of useful links on theWeb Programming wiki page.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I send mail from a Python script?¶",
        "answer": "Use the standard library modulesmtplib. Here’s a very simple interactive mail sender that uses it.  This method will\nwork on any host that supports an SMTP listener. A Unix-only alternative uses sendmail.  The location of the sendmail program\nvaries between systems; sometimes it is/usr/lib/sendmail, sometimes/usr/sbin/sendmail.  The sendmail manual page will help you out.  Here’s\nsome sample code:",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I avoid blocking in the connect() method of a socket?¶",
        "answer": "Theselectmodule is commonly used to help with asynchronous I/O on\nsockets. To prevent the TCP connect from blocking, you can set the socket to non-blocking\nmode.  Then when you do theconnect(),\nyou will either connect immediately\n(unlikely) or get an exception that contains the error number as.errno.errno.EINPROGRESSindicates that the connection is in progress, but hasn’t\nfinished yet.  Different OSes will return different values, so you’re going to\nhave to check what’s returned on your system. You can use theconnect_ex()method\nto avoid creating an exception.\nIt will just return the errno value.\nTo poll, you can callconnect_ex()again later\n–0orerrno.EISCONNindicate that you’re connected – or you can pass this\nsocket toselect.select()to check if it’s writable. Note Theasynciomodule provides a general purpose single-threaded and\nconcurrent asynchronous library, which can be used for writing non-blocking\nnetwork code.\nThe third-partyTwistedlibrary is\na popular and feature-rich alternative.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Databases¶",
        "answer": "Yes. Interfaces to disk-based hashes such asDBMandGDBMare also included with standard Python.  There is also thesqlite3module, which provides a lightweight disk-based relational\ndatabase. Support for most relational databases is available.  See theDatabaseProgramming wiki pagefor details. Thepicklelibrary module solves this in a very general way (though you\nstill can’t store things like open files, sockets or windows), and theshelvelibrary module uses pickle and (g)dbm to create persistent\nmappings containing arbitrary Python objects.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Are there any interfaces to database packages in Python?¶",
        "answer": "Yes. Interfaces to disk-based hashes such asDBMandGDBMare also included with standard Python.  There is also thesqlite3module, which provides a lightweight disk-based relational\ndatabase. Support for most relational databases is available.  See theDatabaseProgramming wiki pagefor details.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do you implement persistent objects in Python?¶",
        "answer": "Thepicklelibrary module solves this in a very general way (though you\nstill can’t store things like open files, sockets or windows), and theshelvelibrary module uses pickle and (g)dbm to create persistent\nmappings containing arbitrary Python objects.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "Mathematics and Numerics¶",
        "answer": "The standard modulerandomimplements a random number generator.  Usage\nis simple: This returns a random floating-point number in the range [0, 1). There are also many other specialized generators in this module, such as: randrange(a,b)chooses an integer in the range [a, b). uniform(a,b)chooses a floating-point number in the range [a, b). normalvariate(mean,sdev)samples the normal (Gaussian) distribution. Some higher-level functions operate on sequences directly, such as: choice(S)chooses a random element from a given sequence. shuffle(L)shuffles a list in-place, i.e. permutes it randomly. There’s also aRandomclass you can instantiate to create independent\nmultiple random number generators.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "How do I generate random numbers in Python?¶",
        "answer": "The standard modulerandomimplements a random number generator.  Usage\nis simple: This returns a random floating-point number in the range [0, 1). There are also many other specialized generators in this module, such as: randrange(a,b)chooses an integer in the range [a, b). uniform(a,b)chooses a floating-point number in the range [a, b). normalvariate(mean,sdev)samples the normal (Gaussian) distribution. Some higher-level functions operate on sequences directly, such as: choice(S)chooses a random element from a given sequence. shuffle(L)shuffles a list in-place, i.e. permutes it randomly. There’s also aRandomclass you can instantiate to create independent\nmultiple random number generators.",
        "source": "data/html/library-extension-faq.html"
    },
    {
        "question": "What is Python?¶",
        "answer": "Python is a programming language.  It’s used for many different applications.\nIt’s used in some high schools and colleges as an introductory programming\nlanguage because Python is easy to learn, but it’s also used by professional\nsoftware developers at places such as Google, NASA, and Lucasfilm Ltd. If you wish to learn more about Python, start with theBeginner’s Guide to\nPython. If you find Python installed on your system but don’t remember installing it,\nthere are several possible ways it could have gotten there. Perhaps another user on the computer wanted to learn programming and installed\nit; you’ll have to figure out who’s been using the machine and might have\ninstalled it. A third-party application installed on the machine might have been written in\nPython and included a Python installation.  There are many such applications,\nfrom GUI programs to network servers and administrative scripts. Some Windows machines also have Python installed.  At this writing we’re aware\nof computers from Hewlett-Packard and Compaq that include Python.  Apparently\nsome of HP/Compaq’s administrative tools are written in Python. Many Unix-compatible operating systems, such as macOS and some Linux\ndistributions, have Python installed by default; it’s included in the base\ninstallation. That depends on where Python came from. If someone installed it deliberately, you can remove it without hurting\nanything.  On Windows, use the Add/Remove Programs icon in the Control Panel. If Python was installed by a third-party application, you can also remove it,\nbut that application will no longer work.  You should use that application’s\nuninstaller rather than removing Python directly. If Python came with your operating system, removing it is not recommended.  If\nyou remove it, whatever tools were written in Python will no longer run, and\nsome of them might be important to you.  Reinstalling the whole system would\nthen be required to fix things again.",
        "source": "data/html/python-installed-faq.html"
    },
    {
        "question": "What is Python?¶",
        "answer": "Python is a programming language.  It’s used for many different applications.\nIt’s used in some high schools and colleges as an introductory programming\nlanguage because Python is easy to learn, but it’s also used by professional\nsoftware developers at places such as Google, NASA, and Lucasfilm Ltd. If you wish to learn more about Python, start with theBeginner’s Guide to\nPython.",
        "source": "data/html/python-installed-faq.html"
    },
    {
        "question": "Why is Python installed on my machine?¶",
        "answer": "If you find Python installed on your system but don’t remember installing it,\nthere are several possible ways it could have gotten there. Perhaps another user on the computer wanted to learn programming and installed\nit; you’ll have to figure out who’s been using the machine and might have\ninstalled it. A third-party application installed on the machine might have been written in\nPython and included a Python installation.  There are many such applications,\nfrom GUI programs to network servers and administrative scripts. Some Windows machines also have Python installed.  At this writing we’re aware\nof computers from Hewlett-Packard and Compaq that include Python.  Apparently\nsome of HP/Compaq’s administrative tools are written in Python. Many Unix-compatible operating systems, such as macOS and some Linux\ndistributions, have Python installed by default; it’s included in the base\ninstallation.",
        "source": "data/html/python-installed-faq.html"
    },
    {
        "question": "Can I delete Python?¶",
        "answer": "That depends on where Python came from. If someone installed it deliberately, you can remove it without hurting\nanything.  On Windows, use the Add/Remove Programs icon in the Control Panel. If Python was installed by a third-party application, you can also remove it,\nbut that application will no longer work.  You should use that application’s\nuninstaller rather than removing Python directly. If Python came with your operating system, removing it is not recommended.  If\nyou remove it, whatever tools were written in Python will no longer run, and\nsome of them might be important to you.  Reinstalling the whole system would\nthen be required to fix things again.",
        "source": "data/html/python-installed-faq.html"
    },
    {
        "question": "How do I run a Python program under Windows?¶",
        "answer": "Contents Python on Windows FAQ How do I run a Python program under Windows? How do I make Python scripts executable? Why does Python sometimes take so long to start? How do I make an executable from a Python script? Is a*.pydfile the same as a DLL? How can I embed Python into a Windows application? How do I keep editors from inserting tabs into my Python source? How do I check for a keypress without blocking? How do I solve the missing api-ms-win-crt-runtime-l1-1-0.dll error? This is not necessarily a straightforward question. If you are already familiar\nwith running programs from the Windows command line then everything will seem\nobvious; otherwise, you might need a little more guidance. Unless you use some sort of integrated development environment, you will end uptypingWindows commands into what is referred to as a\n“Command prompt window”.  Usually you can create such a window from your\nsearch bar by searching forcmd.  You should be able to recognize\nwhen you have started such a window because you will see a Windows “command\nprompt”, which usually looks like this: The letter may be different, and there might be other things after it, so you\nmight just as easily see something like: depending on how your computer has been set up and what else you have recently\ndone with it.  Once you have started such a window, you are well on the way to\nrunning Python programs. You need to realize that your Python scripts have to be processed by another\nprogram called the Pythoninterpreter.  The interpreter reads your script,\ncompiles it into bytecodes, and then executes the bytecodes to run your\nprogram. So, how do you arrange for the interpreter to handle your Python? First, you need to make sure that your command window recognises the word\n“py” as an instruction to start the interpreter.  If you have opened a\ncommand window, you should try entering the commandpyand hitting\nreturn: You should then see something like: You have started the interpreter in “interactive mode”. That means you can enter\nPython statements or expressions interactively and have them executed or\nevaluated while you wait.  This is one of Python’s strongest features.  Check it\nby entering a few expressions of your choice and seeing the results: Many people use the interactive mode as a convenient yet highly programmable\ncalculator.  When you want to end your interactive Python session,\ncall theexit()function or hold theCtrlkey down\nwhile you enter aZ, then hit the “Enter” key to get\nback to your Windows command prompt. You may also find that you have a Start-menu entry such asStart\n‣ Programs ‣ Python 3.x ‣ Python (command line)that results in you\nseeing the>>>prompt in a new window.  If so, the window will disappear\nafter you call theexit()function or enter theCtrl-Zcharacter; Windows is running a single “python”\ncommand in the window, and closes it when you terminate the interpreter. Now that we know thepycommand is recognized, you can give your\nPython script to it. You’ll have to give either an absolute or a\nrelative path to the Python script. Let’s say your Python script is\nlocated in your desktop and is namedhello.py, and your command\nprompt is nicely opened in your home directory so you’re seeing something\nsimilar to: So now you’ll ask thepycommand to give your script to Python by\ntypingpyfollowed by your script path: On Windows, the standard Python installer already associates the .py\nextension with a file type (Python.File) and gives that file type an open\ncommand that runs the interpreter (D:\\ProgramFiles\\Python\\python.exe\"%1\"%*).  This is enough to make scripts executable from the command prompt as\n‘foo.py’.  If you’d rather be able to execute the script by simple typing ‘foo’\nwith no extension you need to add .py to the PATHEXT environment variable. Usually Python starts very quickly on Windows, but occasionally there are bug\nreports that Python suddenly begins to take a long time to start up.  This is\nmade even more puzzling because Python will work fine on other Windows systems\nwhich appear to be configured identically. The problem may be caused by a misconfiguration of virus checking software on\nthe problem machine.  Some virus scanners have been known to introduce startup\noverhead of two orders of magnitude when the scanner is configured to monitor\nall reads from the filesystem.  Try checking the configuration of virus scanning\nsoftware on your systems to ensure that they are indeed configured identically.\nMcAfee, when configured to scan all file system read activity, is a particular\noffender. SeeHow can I create a stand-alone binary from a Python script?for a list of tools that can be used to\nmake executables. Yes, .pyd files are dll’s, but there are a few differences.  If you have a DLL\nnamedfoo.pyd, then it must have a functionPyInit_foo().  You can then\nwrite Python “import foo”, and Python will search for foo.pyd (as well as\nfoo.py, foo.pyc) and if it finds it, will attempt to callPyInit_foo()to\ninitialize it.  You do not link your .exe with foo.lib, as that would cause\nWindows to require the DLL to be present. Note that the search path for foo.pyd is PYTHONPATH, not the same as the path\nthat Windows uses to search for foo.dll.  Also, foo.pyd need not be present to\nrun your program, whereas if you linked your program with a dll, the dll is\nrequired.  Of course, foo.pyd is required if you want to sayimportfoo.  In\na DLL, linkage is declared in the source code with__declspec(dllexport).\nIn a .pyd, linkage is defined in a list of available functions. Embedding the Python interpreter in a Windows app can be summarized as follows: Donotbuild Python into your .exe file directly.  On Windows, Python must\nbe a DLL to handle importing modules that are themselves DLL’s.  (This is the\nfirst key undocumented fact.)  Instead, link topythonNN.dll; it is\ntypically installed inC:\\Windows\\System.NNis the Python version, a\nnumber such as “33” for Python 3.3. You can link to Python in two different ways.  Load-time linking means\nlinking againstpythonNN.lib, while run-time linking means linking\nagainstpythonNN.dll.  (General note:pythonNN.libis the\nso-called “import lib” corresponding topythonNN.dll.  It merely\ndefines symbols for the linker.) Run-time linking greatly simplifies link options; everything happens at run\ntime.  Your code must loadpythonNN.dllusing the WindowsLoadLibraryEx()routine.  The code must also use access routines and data\ninpythonNN.dll(that is, Python’s C API’s) using pointers obtained\nby the WindowsGetProcAddress()routine.  Macros can make using these\npointers transparent to any C code that calls routines in Python’s C API. If you use SWIG, it is easy to create a Python “extension module” that will\nmake the app’s data and methods available to Python.  SWIG will handle just\nabout all the grungy details for you.  The result is C code that you linkintoyour .exe file (!)  You donothave to create a DLL file, and this\nalso simplifies linking. SWIG will create an init function (a C function) whose name depends on the\nname of the extension module.  For example, if the name of the module is leo,\nthe init function will be called initleo().  If you use SWIG shadow classes,\nas you should, the init function will be called initleoc().  This initializes\na mostly hidden helper class used by the shadow class. The reason you can link the C code in step 2 into your .exe file is that\ncalling the initialization function is equivalent to importing the module\ninto Python! (This is the second key undocumented fact.) In short, you can use the following code to initialize the Python interpreter\nwith your extension module. There are two problems with Python’s C API which will become apparent if you\nuse a compiler other than MSVC, the compiler used to build pythonNN.dll. Problem 1: The so-called “Very High Level” functions that takeFILE*arguments will not work in a multi-compiler environment because each\ncompiler’s notion of astructFILEwill be different.  From an implementation\nstandpoint these are very low level functions. Problem 2: SWIG generates the following code when generating wrappers to void\nfunctions: Alas, Py_None is a macro that expands to a reference to a complex data\nstructure called _Py_NoneStruct inside pythonNN.dll.  Again, this code will\nfail in a mult-compiler environment.  Replace such code by: It may be possible to use SWIG’s%typemapcommand to make the change\nautomatically, though I have not been able to get this to work (I’m a\ncomplete SWIG newbie). Using a Python shell script to put up a Python interpreter window from inside\nyour Windows app is not a good idea; the resulting window will be independent\nof your app’s windowing system.  Rather, you (or the wxPythonWindow class)\nshould create a “native” interpreter window.  It is easy to connect that\nwindow to the Python interpreter.  You can redirect Python’s i/o to _any_\nobject that supports read and write, so all you need is a Python object\n(defined in your extension module) that contains read() and write() methods. The FAQ does not recommend using tabs, and the Python style guide,PEP 8,\nrecommends 4 spaces for distributed Python code; this is also the Emacs\npython-mode default. Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no different in\nthis respect, and is easily configured to use spaces: TakeTools\n‣ Options ‣ Tabs, and for file type “Default” set “Tab size” and “Indent\nsize” to 4, and select the “Insert spaces” radio button. Python raisesIndentationErrororTabErrorif mixed tabs\nand spaces are causing problems in leading whitespace.\nYou may also run thetabnannymodule to check a directory tree\nin batch mode. Use themsvcrtmodule.  This is a standard Windows-specific extension module.\nIt defines a functionkbhit()which checks whether a keyboard hit is\npresent, andgetch()which gets one character without echoing it. This can occur on Python 3.5 and later when using Windows 8.1 or earlier without all updates having been installed.\nFirst ensure your operating system is supported and is up to date, and if that does not resolve the issue,\nvisit theMicrosoft support pagefor guidance on manually installing the C Runtime update.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I run a Python program under Windows?¶",
        "answer": "This is not necessarily a straightforward question. If you are already familiar\nwith running programs from the Windows command line then everything will seem\nobvious; otherwise, you might need a little more guidance. Unless you use some sort of integrated development environment, you will end uptypingWindows commands into what is referred to as a\n“Command prompt window”.  Usually you can create such a window from your\nsearch bar by searching forcmd.  You should be able to recognize\nwhen you have started such a window because you will see a Windows “command\nprompt”, which usually looks like this: The letter may be different, and there might be other things after it, so you\nmight just as easily see something like: depending on how your computer has been set up and what else you have recently\ndone with it.  Once you have started such a window, you are well on the way to\nrunning Python programs. You need to realize that your Python scripts have to be processed by another\nprogram called the Pythoninterpreter.  The interpreter reads your script,\ncompiles it into bytecodes, and then executes the bytecodes to run your\nprogram. So, how do you arrange for the interpreter to handle your Python? First, you need to make sure that your command window recognises the word\n“py” as an instruction to start the interpreter.  If you have opened a\ncommand window, you should try entering the commandpyand hitting\nreturn: You should then see something like: You have started the interpreter in “interactive mode”. That means you can enter\nPython statements or expressions interactively and have them executed or\nevaluated while you wait.  This is one of Python’s strongest features.  Check it\nby entering a few expressions of your choice and seeing the results: Many people use the interactive mode as a convenient yet highly programmable\ncalculator.  When you want to end your interactive Python session,\ncall theexit()function or hold theCtrlkey down\nwhile you enter aZ, then hit the “Enter” key to get\nback to your Windows command prompt. You may also find that you have a Start-menu entry such asStart\n‣ Programs ‣ Python 3.x ‣ Python (command line)that results in you\nseeing the>>>prompt in a new window.  If so, the window will disappear\nafter you call theexit()function or enter theCtrl-Zcharacter; Windows is running a single “python”\ncommand in the window, and closes it when you terminate the interpreter. Now that we know thepycommand is recognized, you can give your\nPython script to it. You’ll have to give either an absolute or a\nrelative path to the Python script. Let’s say your Python script is\nlocated in your desktop and is namedhello.py, and your command\nprompt is nicely opened in your home directory so you’re seeing something\nsimilar to: So now you’ll ask thepycommand to give your script to Python by\ntypingpyfollowed by your script path:",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I make Python scripts executable?¶",
        "answer": "On Windows, the standard Python installer already associates the .py\nextension with a file type (Python.File) and gives that file type an open\ncommand that runs the interpreter (D:\\ProgramFiles\\Python\\python.exe\"%1\"%*).  This is enough to make scripts executable from the command prompt as\n‘foo.py’.  If you’d rather be able to execute the script by simple typing ‘foo’\nwith no extension you need to add .py to the PATHEXT environment variable.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "Why does Python sometimes take so long to start?¶",
        "answer": "Usually Python starts very quickly on Windows, but occasionally there are bug\nreports that Python suddenly begins to take a long time to start up.  This is\nmade even more puzzling because Python will work fine on other Windows systems\nwhich appear to be configured identically. The problem may be caused by a misconfiguration of virus checking software on\nthe problem machine.  Some virus scanners have been known to introduce startup\noverhead of two orders of magnitude when the scanner is configured to monitor\nall reads from the filesystem.  Try checking the configuration of virus scanning\nsoftware on your systems to ensure that they are indeed configured identically.\nMcAfee, when configured to scan all file system read activity, is a particular\noffender.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I make an executable from a Python script?¶",
        "answer": "SeeHow can I create a stand-alone binary from a Python script?for a list of tools that can be used to\nmake executables.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "Is a*.pydfile the same as a DLL?¶",
        "answer": "Yes, .pyd files are dll’s, but there are a few differences.  If you have a DLL\nnamedfoo.pyd, then it must have a functionPyInit_foo().  You can then\nwrite Python “import foo”, and Python will search for foo.pyd (as well as\nfoo.py, foo.pyc) and if it finds it, will attempt to callPyInit_foo()to\ninitialize it.  You do not link your .exe with foo.lib, as that would cause\nWindows to require the DLL to be present. Note that the search path for foo.pyd is PYTHONPATH, not the same as the path\nthat Windows uses to search for foo.dll.  Also, foo.pyd need not be present to\nrun your program, whereas if you linked your program with a dll, the dll is\nrequired.  Of course, foo.pyd is required if you want to sayimportfoo.  In\na DLL, linkage is declared in the source code with__declspec(dllexport).\nIn a .pyd, linkage is defined in a list of available functions.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How can I embed Python into a Windows application?¶",
        "answer": "Embedding the Python interpreter in a Windows app can be summarized as follows: Donotbuild Python into your .exe file directly.  On Windows, Python must\nbe a DLL to handle importing modules that are themselves DLL’s.  (This is the\nfirst key undocumented fact.)  Instead, link topythonNN.dll; it is\ntypically installed inC:\\Windows\\System.NNis the Python version, a\nnumber such as “33” for Python 3.3. You can link to Python in two different ways.  Load-time linking means\nlinking againstpythonNN.lib, while run-time linking means linking\nagainstpythonNN.dll.  (General note:pythonNN.libis the\nso-called “import lib” corresponding topythonNN.dll.  It merely\ndefines symbols for the linker.) Run-time linking greatly simplifies link options; everything happens at run\ntime.  Your code must loadpythonNN.dllusing the WindowsLoadLibraryEx()routine.  The code must also use access routines and data\ninpythonNN.dll(that is, Python’s C API’s) using pointers obtained\nby the WindowsGetProcAddress()routine.  Macros can make using these\npointers transparent to any C code that calls routines in Python’s C API. If you use SWIG, it is easy to create a Python “extension module” that will\nmake the app’s data and methods available to Python.  SWIG will handle just\nabout all the grungy details for you.  The result is C code that you linkintoyour .exe file (!)  You donothave to create a DLL file, and this\nalso simplifies linking. SWIG will create an init function (a C function) whose name depends on the\nname of the extension module.  For example, if the name of the module is leo,\nthe init function will be called initleo().  If you use SWIG shadow classes,\nas you should, the init function will be called initleoc().  This initializes\na mostly hidden helper class used by the shadow class. The reason you can link the C code in step 2 into your .exe file is that\ncalling the initialization function is equivalent to importing the module\ninto Python! (This is the second key undocumented fact.) In short, you can use the following code to initialize the Python interpreter\nwith your extension module. There are two problems with Python’s C API which will become apparent if you\nuse a compiler other than MSVC, the compiler used to build pythonNN.dll. Problem 1: The so-called “Very High Level” functions that takeFILE*arguments will not work in a multi-compiler environment because each\ncompiler’s notion of astructFILEwill be different.  From an implementation\nstandpoint these are very low level functions. Problem 2: SWIG generates the following code when generating wrappers to void\nfunctions: Alas, Py_None is a macro that expands to a reference to a complex data\nstructure called _Py_NoneStruct inside pythonNN.dll.  Again, this code will\nfail in a mult-compiler environment.  Replace such code by: It may be possible to use SWIG’s%typemapcommand to make the change\nautomatically, though I have not been able to get this to work (I’m a\ncomplete SWIG newbie). Using a Python shell script to put up a Python interpreter window from inside\nyour Windows app is not a good idea; the resulting window will be independent\nof your app’s windowing system.  Rather, you (or the wxPythonWindow class)\nshould create a “native” interpreter window.  It is easy to connect that\nwindow to the Python interpreter.  You can redirect Python’s i/o to _any_\nobject that supports read and write, so all you need is a Python object\n(defined in your extension module) that contains read() and write() methods.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I keep editors from inserting tabs into my Python source?¶",
        "answer": "The FAQ does not recommend using tabs, and the Python style guide,PEP 8,\nrecommends 4 spaces for distributed Python code; this is also the Emacs\npython-mode default. Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no different in\nthis respect, and is easily configured to use spaces: TakeTools\n‣ Options ‣ Tabs, and for file type “Default” set “Tab size” and “Indent\nsize” to 4, and select the “Insert spaces” radio button. Python raisesIndentationErrororTabErrorif mixed tabs\nand spaces are causing problems in leading whitespace.\nYou may also run thetabnannymodule to check a directory tree\nin batch mode.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I check for a keypress without blocking?¶",
        "answer": "Use themsvcrtmodule.  This is a standard Windows-specific extension module.\nIt defines a functionkbhit()which checks whether a keyboard hit is\npresent, andgetch()which gets one character without echoing it.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "How do I solve the missing api-ms-win-crt-runtime-l1-1-0.dll error?¶",
        "answer": "This can occur on Python 3.5 and later when using Windows 8.1 or earlier without all updates having been installed.\nFirst ensure your operating system is supported and is up to date, and if that does not resolve the issue,\nvisit theMicrosoft support pagefor guidance on manually installing the C Runtime update.",
        "source": "data/html/python-windows-faq.html"
    },
    {
        "question": "Why does Python use indentation for grouping of statements?¶",
        "answer": "Contents Design and History FAQ Why does Python use indentation for grouping of statements? Why am I getting strange results with simple arithmetic operations? Why are floating-point calculations so inaccurate? Why are Python strings immutable? Why must ‘self’ be used explicitly in method definitions and calls? Why can’t I use an assignment in an expression? Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))? Why is join() a string method instead of a list or tuple method? How fast are exceptions? Why isn’t there a switch or case statement in Python? Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation? Why can’t lambda expressions contain statements? Can Python be compiled to machine code, C or some other language? How does Python manage memory? Why doesn’t CPython use a more traditional garbage collection scheme? Why isn’t all memory freed when CPython exits? Why are there separate tuple and list data types? How are lists implemented in CPython? How are dictionaries implemented in CPython? Why must dictionary keys be immutable? Why doesn’t list.sort() return the sorted list? How do you specify and enforce an interface spec in Python? Why is there no goto? Why can’t raw strings (r-strings) end with a backslash? Why doesn’t Python have a “with” statement for attribute assignments? Why don’t generators support the with statement? Why are colons required for the if/while/def/class statements? Why does Python allow commas at the end of lists and tuples? Guido van Rossum believes that using indentation for grouping is extremely\nelegant and contributes a lot to the clarity of the average Python program.\nMost people learn to love this feature after a while. Since there are no begin/end brackets there cannot be a disagreement between\ngrouping perceived by the parser and the human reader.  Occasionally C\nprogrammers will encounter a fragment of code like this: Only thex++statement is executed if the condition is true, but the\nindentation leads many to believe otherwise.  Even experienced C programmers will\nsometimes stare at it a long time wondering as to whyyis being decremented even\nforx>y. Because there are no begin/end brackets, Python is much less prone to\ncoding-style conflicts.  In C there are many different ways to place the braces.\nAfter becoming used to reading and writing code using a particular style,\nit is normal to feel somewhat uneasy when reading (or being required to write)\nin a different one. Many coding styles place begin/end brackets on a line by themselves.  This makes\nprograms considerably longer and wastes valuable screen space, making it harder\nto get a good overview of a program.  Ideally, a function should fit on one\nscreen (say, 20–30 lines).  20 lines of Python can do a lot more work than 20\nlines of C.  This is not solely due to the lack of begin/end brackets – the\nlack of declarations and the high-level data types are also responsible – but\nthe indentation-based syntax certainly helps. See the next question. Users are often surprised by results like this: and think it is a bug in Python.  It’s not.  This has little to do with Python,\nand much more to do with how the underlying platform handles floating-point\nnumbers. Thefloattype in CPython uses a Cdoublefor storage.  Afloatobject’s value is stored in binary floating-point with a fixed\nprecision (typically 53 bits) and Python uses C operations, which in turn rely\non the hardware implementation in the processor, to perform floating-point\noperations. This means that as far as floating-point operations are concerned,\nPython behaves like many popular languages including C and Java. Many numbers that can be written easily in decimal notation cannot be expressed\nexactly in binary floating point.  For example, after: the value stored forxis a (very good) approximation to the decimal value1.2, but is not exactly equal to it.  On a typical machine, the actual\nstored value is: which is exactly: The typical precision of 53 bits provides Python floats with 15–16\ndecimal digits of accuracy. For a fuller explanation, please see thefloating-point arithmeticchapter in the Python tutorial. There are several advantages. One is performance: knowing that a string is immutable means we can allocate\nspace for it at creation time, and the storage requirements are fixed and\nunchanging.  This is also one of the reasons for the distinction between tuples\nand lists. Another advantage is that strings in Python are considered as “elemental” as\nnumbers.  No amount of activity will change the value 8 to anything else, and in\nPython, no amount of activity will change the string “eight” to anything else. The idea was borrowed from Modula-3.  It turns out to be very useful, for a\nvariety of reasons. First, it’s more obvious that you are using a method or instance attribute\ninstead of a local variable.  Readingself.xorself.meth()makes it\nabsolutely clear that an instance variable or method is used even if you don’t\nknow the class definition by heart.  In C++, you can sort of tell by the lack of\na local variable declaration (assuming globals are rare or easily recognizable)\n– but in Python, there are no local variable declarations, so you’d have to\nlook up the class definition to be sure.  Some C++ and Java coding standards\ncall for instance attributes to have anm_prefix, so this explicitness is\nstill useful in those languages, too. Second, it means that no special syntax is necessary if you want to explicitly\nreference or call the method from a particular class.  In C++, if you want to\nuse a method from a base class which is overridden in a derived class, you have\nto use the::operator – in Python you can writebaseclass.methodname(self,<argumentlist>).  This is particularly useful\nfor__init__()methods, and in general in cases where a derived class\nmethod wants to extend the base class method of the same name and thus has to\ncall the base class method somehow. Finally, for instance variables it solves a syntactic problem with assignment:\nsince local variables in Python are (by definition!) those variables to which a\nvalue is assigned in a function body (and that aren’t explicitly declared\nglobal), there has to be some way to tell the interpreter that an assignment was\nmeant to assign to an instance variable instead of to a local variable, and it\nshould preferably be syntactic (for efficiency reasons).  C++ does this through\ndeclarations, but Python doesn’t have declarations and it would be a pity having\nto introduce them just for this purpose.  Using the explicitself.varsolves\nthis nicely.  Similarly, for using instance variables, having to writeself.varmeans that references to unqualified names inside a method don’t\nhave to search the instance’s directories.  To put it another way, local\nvariables and instance variables live in two different namespaces, and you need\nto tell Python which namespace to use. Starting in Python 3.8, you can! Assignment expressions using the walrus operator:=assign a variable in an\nexpression: SeePEP 572for more information. As Guido said: (a) For some operations, prefix notation just reads better than\npostfix – prefix (and infix!) operations have a long tradition in\nmathematics which likes notations where the visuals help the\nmathematician thinking about a problem. Compare the easy with which we\nrewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of\ndoing the same thing using a raw OO notation.(b) When I read code that says len(x) Iknowthat it is asking for\nthe length of something. This tells me two things: the result is an\ninteger, and the argument is some kind of container. To the contrary,\nwhen I read x.len(), I have to already know that x is some kind of\ncontainer implementing an interface or inheriting from a class that\nhas a standard len(). Witness the confusion we occasionally have when\na class that is not implementing a mapping has a get() or keys()\nmethod, or something that isn’t a file has a write() method.—https://mail.python.org/pipermail/python-3000/2006-November/004643.html (a) For some operations, prefix notation just reads better than\npostfix – prefix (and infix!) operations have a long tradition in\nmathematics which likes notations where the visuals help the\nmathematician thinking about a problem. Compare the easy with which we\nrewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of\ndoing the same thing using a raw OO notation. (b) When I read code that says len(x) Iknowthat it is asking for\nthe length of something. This tells me two things: the result is an\ninteger, and the argument is some kind of container. To the contrary,\nwhen I read x.len(), I have to already know that x is some kind of\ncontainer implementing an interface or inheriting from a class that\nhas a standard len(). Witness the confusion we occasionally have when\na class that is not implementing a mapping has a get() or keys()\nmethod, or something that isn’t a file has a write() method. —https://mail.python.org/pipermail/python-3000/2006-November/004643.html Strings became much more like other standard types starting in Python 1.6, when\nmethods were added which give the same functionality that has always been\navailable using the functions of the string module.  Most of these new methods\nhave been widely accepted, but the one which appears to make some programmers\nfeel uncomfortable is: which gives the result: There are two common arguments against this usage. The first runs along the lines of: “It looks really ugly using a method of a\nstring literal (string constant)”, to which the answer is that it might, but a\nstring literal is just a fixed value. If the methods are to be allowed on names\nbound to strings there is no logical reason to make them unavailable on\nliterals. The second objection is typically cast as: “I am really telling a sequence to\njoin its members together with a string constant”.  Sadly, you aren’t.  For some\nreason there seems to be much less difficulty with havingsplit()as\na string method, since in that case it is easy to see that is an instruction to a string literal to return the substrings delimited by the\ngiven separator (or, by default, arbitrary runs of white space). join()is a string method because in using it you are telling the\nseparator string to iterate over a sequence of strings and insert itself between\nadjacent elements.  This method can be used with any argument which obeys the\nrules for sequence objects, including any new classes you might define yourself.\nSimilar methods exist for bytes and bytearray objects. Atry/exceptblock is extremely efficient if no exceptions\nare raised.  Actually\ncatching an exception is expensive.  In versions of Python prior to 2.0 it was\ncommon to use this idiom: This only made sense when you expected the dict to have the key almost all the\ntime.  If that wasn’t the case, you coded it like this: For this specific case, you could also usevalue=dict.setdefault(key,getvalue(key)), but only if thegetvalue()call is cheap enough because it\nis evaluated in all cases. In general, structured switch statements execute one block of code\nwhen an expression has a particular value or set of values.\nSince Python 3.10 one can easily match literal values, or constants\nwithin a namespace, with amatch...casestatement.\nAn older alternative is a sequence ofif...elif...elif...else. For cases where you need to choose from a very large number of possibilities,\nyou can create a dictionary mapping case values to functions to call.  For\nexample: For calling methods on objects, you can simplify yet further by using thegetattr()built-in to retrieve methods with a particular name: It’s suggested that you use a prefix for the method names, such asvisit_in\nthis example.  Without such a prefix, if values are coming from an untrusted\nsource, an attacker would be able to call any method on your object. Imitating switch with fallthrough, as with C’s switch-case-default,\nis possible, much harder, and less needed. Answer 1: Unfortunately, the interpreter pushes at least one C stack frame for\neach Python stack frame.  Also, extensions can call back into Python at almost\nrandom moments.  Therefore, a complete threads implementation requires thread\nsupport for C. Answer 2: Fortunately, there isStackless Python,\nwhich has a completely redesigned interpreter loop that avoids the C stack. Python lambda expressions cannot contain statements because Python’s syntactic\nframework can’t handle statements nested inside expressions.  However, in\nPython, this is not a serious problem.  Unlike lambda forms in other languages,\nwhere they add functionality, Python lambdas are only a shorthand notation if\nyou’re too lazy to define a function. Functions are already first class objects in Python, and can be declared in a\nlocal scope.  Therefore the only advantage of using a lambda instead of a\nlocally defined function is that you don’t need to invent a name for the\nfunction – but that’s just a local variable to which the function object (which\nis exactly the same type of object that a lambda expression yields) is assigned! Cythoncompiles a modified version of Python with\noptional annotations into C extensions.Nuitkais\nan up-and-coming compiler of Python into C++ code, aiming to support the full\nPython language. The details of Python memory management depend on the implementation.  The\nstandard implementation of Python,CPython, uses reference counting to\ndetect inaccessible objects, and another mechanism to collect reference cycles,\nperiodically executing a cycle detection algorithm which looks for inaccessible\ncycles and deletes the objects involved. Thegcmodule provides functions\nto perform a garbage collection, obtain debugging statistics, and tune the\ncollector’s parameters. Other implementations (such asJythonorPyPy), however, can rely on a different mechanism\nsuch as a full-blown garbage collector.  This difference can cause some\nsubtle porting problems if your Python code depends on the behavior of the\nreference counting implementation. In some Python implementations, the following code (which is fine in CPython)\nwill probably run out of file descriptors: Indeed, using CPython’s reference counting and destructor scheme, each new\nassignment tofcloses the previous file.  With a traditional GC, however,\nthose file objects will only get collected (and closed) at varying and possibly\nlong intervals. If you want to write code that will work with any Python implementation,\nyou should explicitly close the file or use thewithstatement;\nthis will work regardless of memory management scheme: For one thing, this is not a C standard feature and hence it’s not portable.\n(Yes, we know about the Boehm GC library.  It has bits of assembler code formostcommon platforms, not for all of them, and although it is mostly\ntransparent, it isn’t completely transparent; patches are required to get\nPython to work with it.) Traditional GC also becomes a problem when Python is embedded into other\napplications.  While in a standalone Python it’s fine to replace the standardmalloc()andfree()with versions provided by the GC library, an application\nembedding Python may want to have itsownsubstitute formalloc()andfree(),\nand may not want Python’s.  Right now, CPython works with anything that\nimplementsmalloc()andfree()properly. Objects referenced from the global namespaces of Python modules are not always\ndeallocated when Python exits.  This may happen if there are circular\nreferences.  There are also certain bits of memory that are allocated by the C\nlibrary that are impossible to free (e.g. a tool like Purify will complain about\nthese).  Python is, however, aggressive about cleaning up memory on exit and\ndoes try to destroy every single object. If you want to force Python to delete certain things on deallocation use theatexitmodule to run a function that will force those deletions. Lists and tuples, while similar in many respects, are generally used in\nfundamentally different ways.  Tuples can be thought of as being similar to\nPascalrecordsor Cstructs; they’re small collections of related data which may\nbe of different types which are operated on as a group.  For example, a\nCartesian coordinate is appropriately represented as a tuple of two or three\nnumbers. Lists, on the other hand, are more like arrays in other languages.  They tend to\nhold a varying number of objects all of which have the same type and which are\noperated on one-by-one.  For example,os.listdir('.')returns a list of\nstrings representing the files in the current directory.  Functions which\noperate on this output would generally not break if you added another file or\ntwo to the directory. Tuples are immutable, meaning that once a tuple has been created, you can’t\nreplace any of its elements with a new value.  Lists are mutable, meaning that\nyou can always change a list’s elements.  Only immutable elements can be used as\ndictionary keys, and hence only tuples and not lists can be used as keys. CPython’s lists are really variable-length arrays, not Lisp-style linked lists.\nThe implementation uses a contiguous array of references to other objects, and\nkeeps a pointer to this array and the array’s length in a list head structure. This makes indexing a lista[i]an operation whose cost is independent of\nthe size of the list or the value of the index. When items are appended or inserted, the array of references is resized.  Some\ncleverness is applied to improve the performance of appending items repeatedly;\nwhen the array must be grown, some extra space is allocated so the next few\ntimes don’t require an actual resize. CPython’s dictionaries are implemented as resizable hash tables.  Compared to\nB-trees, this gives better performance for lookup (the most common operation by\nfar) under most circumstances, and the implementation is simpler. Dictionaries work by computing a hash code for each key stored in the dictionary\nusing thehash()built-in function.  The hash code varies widely depending\non the key and a per-process seed; for example,'Python'could hash to-539294296while'python', a string that differs by a single bit, could hash\nto1142331976.  The hash code is then used to calculate a location in an\ninternal array where the value will be stored.  Assuming that you’re storing\nkeys that all have different hash values, this means that dictionaries take\nconstant time –O(1), in Big-O notation – to retrieve a key. The hash table implementation of dictionaries uses a hash value calculated from\nthe key value to find the key.  If the key were a mutable object, its value\ncould change, and thus its hash could also change.  But since whoever changes\nthe key object can’t tell that it was being used as a dictionary key, it can’t\nmove the entry around in the dictionary.  Then, when you try to look up the same\nobject in the dictionary it won’t be found because its hash value is different.\nIf you tried to look up the old value it wouldn’t be found either, because the\nvalue of the object found in that hash bin would be different. If you want a dictionary indexed with a list, simply convert the list to a tuple\nfirst; the functiontuple(L)creates a tuple with the same entries as the\nlistL.  Tuples are immutable and can therefore be used as dictionary keys. Some unacceptable solutions that have been proposed: Hash lists by their address (object ID).  This doesn’t work because if you\nconstruct a new list with the same value it won’t be found; e.g.: would raise aKeyErrorexception because the id of the[1,2]used in the\nsecond line differs from that in the first line.  In other words, dictionary\nkeys should be compared using==, not usingis. Make a copy when using a list as a key.  This doesn’t work because the list,\nbeing a mutable object, could contain a reference to itself, and then the\ncopying code would run into an infinite loop. Allow lists as keys but tell the user not to modify them.  This would allow a\nclass of hard-to-track bugs in programs when you forgot or modified a list by\naccident. It also invalidates an important invariant of dictionaries: every\nvalue ind.keys()is usable as a key of the dictionary. Mark lists as read-only once they are used as a dictionary key.  The problem\nis that it’s not just the top-level object that could change its value; you\ncould use a tuple containing a list as a key.  Entering anything as a key into\na dictionary would require marking all objects reachable from there as\nread-only – and again, self-referential objects could cause an infinite loop. There is a trick to get around this if you need to, but use it at your own risk:\nYou can wrap a mutable structure inside a class instance which has both a__eq__()and a__hash__()method.\nYou must then make sure that the\nhash value for all such wrapper objects that reside in a dictionary (or other\nhash based structure), remain fixed while the object is in the dictionary (or\nother structure). Note that the hash computation is complicated by the possibility that some\nmembers of the list may be unhashable and also by the possibility of arithmetic\noverflow. Furthermore it must always be the case that ifo1==o2(ieo1.__eq__(o2)isTrue) thenhash(o1)==hash(o2)(ie,o1.__hash__()==o2.__hash__()),\nregardless of whether the object is in a dictionary or not.  If you fail to meet\nthese restrictions dictionaries and other hash based structures will misbehave. In the case ofListWrapper, whenever the wrapper object is in a dictionary the\nwrapped list must not change to avoid anomalies.  Don’t do this unless you are\nprepared to think hard about the requirements and the consequences of not\nmeeting them correctly.  Consider yourself warned. In situations where performance matters, making a copy of the list just to sort\nit would be wasteful. Therefore,list.sort()sorts the list in place. In\norder to remind you of that fact, it does not return the sorted list.  This way,\nyou won’t be fooled into accidentally overwriting a list when you need a sorted\ncopy but also need to keep the unsorted version around. If you want to return a new list, use the built-insorted()function\ninstead.  This function creates a new list from a provided iterable, sorts\nit and returns it.  For example, here’s how to iterate over the keys of a\ndictionary in sorted order: An interface specification for a module as provided by languages such as C++ and\nJava describes the prototypes for the methods and functions of the module.  Many\nfeel that compile-time enforcement of interface specifications helps in the\nconstruction of large programs. Python 2.6 adds anabcmodule that lets you define Abstract Base Classes\n(ABCs).  You can then useisinstance()andissubclass()to check\nwhether an instance or a class implements a particular ABC.  Thecollections.abcmodule defines a set of useful ABCs such asIterable,Container, andMutableMapping. For Python, many of the advantages of interface specifications can be obtained\nby an appropriate test discipline for components. A good test suite for a module can both provide a regression test and serve as a\nmodule interface specification and a set of examples.  Many Python modules can\nbe run as a script to provide a simple “self test.”  Even modules which use\ncomplex external interfaces can often be tested in isolation using trivial\n“stub” emulations of the external interface.  Thedoctestandunittestmodules or third-party test frameworks can be used to construct\nexhaustive test suites that exercise every line of code in a module. An appropriate testing discipline can help build large complex applications in\nPython as well as having interface specifications would.  In fact, it can be\nbetter because an interface specification cannot test certain properties of a\nprogram.  For example, thelist.append()method is expected to add new elements\nto the end of some internal list; an interface specification cannot test that\nyourlist.append()implementation will actually do this correctly, but it’s\ntrivial to check this property in a test suite. Writing test suites is very helpful, and you might want to design your code to\nmake it easily tested. One increasingly popular technique, test-driven\ndevelopment, calls for writing parts of the test suite first, before you write\nany of the actual code.  Of course Python allows you to be sloppy and not write\ntest cases at all. In the 1970s people realized that unrestricted goto could lead\nto messy “spaghetti” code that was hard to understand and revise.\nIn a high-level language, it is also unneeded as long as there\nare ways to branch (in Python, withifstatements andor,and, andif/elseexpressions) and loop (withwhileandforstatements, possibly containingcontinueandbreak). One can also use exceptions to provide a “structured goto”\nthat works even across\nfunction calls.  Many feel that exceptions can conveniently emulate all\nreasonable uses of thegoorgotoconstructs of C, Fortran, and other\nlanguages.  For example: This doesn’t allow you to jump into the middle of a loop, but that’s usually\nconsidered an abuse ofgotoanyway.  Use sparingly. More precisely, they can’t end with an odd number of backslashes: the unpaired\nbackslash at the end escapes the closing quote character, leaving an\nunterminated string. Raw strings were designed to ease creating input for processors (chiefly regular\nexpression engines) that want to do their own backslash escape processing. Such\nprocessors consider an unmatched trailing backslash to be an error anyway, so\nraw strings disallow that.  In return, they allow you to pass on the string\nquote character by escaping it with a backslash.  These rules work well when\nr-strings are used for their intended purpose. If you’re trying to build Windows pathnames, note that all Windows system calls\naccept forward slashes too: If you’re trying to build a pathname for a DOS command, try e.g. one of Python has awithstatement that wraps the execution of a block, calling code\non the entrance and exit from the block.  Some languages have a construct that\nlooks like this: In Python, such a construct would be ambiguous. Other languages, such as Object Pascal, Delphi, and C++, use static types, so\nit’s possible to know, in an unambiguous way, what member is being assigned\nto. This is the main point of static typing – the compileralwaysknows the\nscope of every variable at compile time. Python uses dynamic types. It is impossible to know in advance which attribute\nwill be referenced at runtime. Member attributes may be added or removed from\nobjects on the fly. This makes it impossible to know, from a simple reading,\nwhat attribute is being referenced: a local one, a global one, or a member\nattribute? For instance, take the following incomplete snippet: The snippet assumes thatamust have a member attribute calledx. However,\nthere is nothing in Python that tells the interpreter this. What should happen\nifais, let us say, an integer?  If there is a global variable namedx,\nwill it be used inside thewithblock?  As you see, the dynamic nature of Python\nmakes such choices much harder. The primary benefit ofwithand similar language features (reduction of code\nvolume) can, however, easily be achieved in Python by assignment.  Instead of: write this: This also has the side-effect of increasing execution speed because name\nbindings are resolved at run-time in Python, and the second version only needs\nto perform the resolution once. Similar proposals that would introduce syntax to further reduce code volume,\nsuch as using a ‘leading dot’, have been rejected in favour of explicitness (seehttps://mail.python.org/pipermail/python-ideas/2016-May/040070.html). For technical reasons, a generator used directly as a context manager\nwould not work correctly.  When, as is most common, a generator is used as\nan iterator run to completion, no closing is needed.  When it is, wrap\nit ascontextlib.closing(generator)in thewithstatement. The colon is required primarily to enhance readability (one of the results of\nthe experimental ABC language).  Consider this: versus Notice how the second one is slightly easier to read.  Notice further how a\ncolon sets off the example in this FAQ answer; it’s a standard usage in English. Another minor reason is that the colon makes it easier for editors with syntax\nhighlighting; they can look for colons to decide when indentation needs to be\nincreased instead of having to do a more elaborate parsing of the program text. Python lets you add a trailing comma at the end of lists, tuples, and\ndictionaries: There are several reasons to allow this. When you have a literal value for a list, tuple, or dictionary spread across\nmultiple lines, it’s easier to add more elements because you don’t have to\nremember to add a comma to the previous line.  The lines can also be reordered\nwithout creating a syntax error. Accidentally omitting the comma can lead to errors that are hard to diagnose.\nFor example: This list looks like it has four elements, but it actually contains three:\n“fee”, “fiefoo” and “fum”.  Always adding the comma avoids this source of error. Allowing the trailing comma may also make programmatic code generation easier.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why does Python use indentation for grouping of statements?¶",
        "answer": "Guido van Rossum believes that using indentation for grouping is extremely\nelegant and contributes a lot to the clarity of the average Python program.\nMost people learn to love this feature after a while. Since there are no begin/end brackets there cannot be a disagreement between\ngrouping perceived by the parser and the human reader.  Occasionally C\nprogrammers will encounter a fragment of code like this: Only thex++statement is executed if the condition is true, but the\nindentation leads many to believe otherwise.  Even experienced C programmers will\nsometimes stare at it a long time wondering as to whyyis being decremented even\nforx>y. Because there are no begin/end brackets, Python is much less prone to\ncoding-style conflicts.  In C there are many different ways to place the braces.\nAfter becoming used to reading and writing code using a particular style,\nit is normal to feel somewhat uneasy when reading (or being required to write)\nin a different one. Many coding styles place begin/end brackets on a line by themselves.  This makes\nprograms considerably longer and wastes valuable screen space, making it harder\nto get a good overview of a program.  Ideally, a function should fit on one\nscreen (say, 20–30 lines).  20 lines of Python can do a lot more work than 20\nlines of C.  This is not solely due to the lack of begin/end brackets – the\nlack of declarations and the high-level data types are also responsible – but\nthe indentation-based syntax certainly helps.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why am I getting strange results with simple arithmetic operations?¶",
        "answer": "See the next question.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why are floating-point calculations so inaccurate?¶",
        "answer": "Users are often surprised by results like this: and think it is a bug in Python.  It’s not.  This has little to do with Python,\nand much more to do with how the underlying platform handles floating-point\nnumbers. Thefloattype in CPython uses a Cdoublefor storage.  Afloatobject’s value is stored in binary floating-point with a fixed\nprecision (typically 53 bits) and Python uses C operations, which in turn rely\non the hardware implementation in the processor, to perform floating-point\noperations. This means that as far as floating-point operations are concerned,\nPython behaves like many popular languages including C and Java. Many numbers that can be written easily in decimal notation cannot be expressed\nexactly in binary floating point.  For example, after: the value stored forxis a (very good) approximation to the decimal value1.2, but is not exactly equal to it.  On a typical machine, the actual\nstored value is: which is exactly: The typical precision of 53 bits provides Python floats with 15–16\ndecimal digits of accuracy. For a fuller explanation, please see thefloating-point arithmeticchapter in the Python tutorial.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why are Python strings immutable?¶",
        "answer": "There are several advantages. One is performance: knowing that a string is immutable means we can allocate\nspace for it at creation time, and the storage requirements are fixed and\nunchanging.  This is also one of the reasons for the distinction between tuples\nand lists. Another advantage is that strings in Python are considered as “elemental” as\nnumbers.  No amount of activity will change the value 8 to anything else, and in\nPython, no amount of activity will change the string “eight” to anything else.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why must ‘self’ be used explicitly in method definitions and calls?¶",
        "answer": "The idea was borrowed from Modula-3.  It turns out to be very useful, for a\nvariety of reasons. First, it’s more obvious that you are using a method or instance attribute\ninstead of a local variable.  Readingself.xorself.meth()makes it\nabsolutely clear that an instance variable or method is used even if you don’t\nknow the class definition by heart.  In C++, you can sort of tell by the lack of\na local variable declaration (assuming globals are rare or easily recognizable)\n– but in Python, there are no local variable declarations, so you’d have to\nlook up the class definition to be sure.  Some C++ and Java coding standards\ncall for instance attributes to have anm_prefix, so this explicitness is\nstill useful in those languages, too. Second, it means that no special syntax is necessary if you want to explicitly\nreference or call the method from a particular class.  In C++, if you want to\nuse a method from a base class which is overridden in a derived class, you have\nto use the::operator – in Python you can writebaseclass.methodname(self,<argumentlist>).  This is particularly useful\nfor__init__()methods, and in general in cases where a derived class\nmethod wants to extend the base class method of the same name and thus has to\ncall the base class method somehow. Finally, for instance variables it solves a syntactic problem with assignment:\nsince local variables in Python are (by definition!) those variables to which a\nvalue is assigned in a function body (and that aren’t explicitly declared\nglobal), there has to be some way to tell the interpreter that an assignment was\nmeant to assign to an instance variable instead of to a local variable, and it\nshould preferably be syntactic (for efficiency reasons).  C++ does this through\ndeclarations, but Python doesn’t have declarations and it would be a pity having\nto introduce them just for this purpose.  Using the explicitself.varsolves\nthis nicely.  Similarly, for using instance variables, having to writeself.varmeans that references to unqualified names inside a method don’t\nhave to search the instance’s directories.  To put it another way, local\nvariables and instance variables live in two different namespaces, and you need\nto tell Python which namespace to use.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why can’t I use an assignment in an expression?¶",
        "answer": "Starting in Python 3.8, you can! Assignment expressions using the walrus operator:=assign a variable in an\nexpression: SeePEP 572for more information.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?¶",
        "answer": "As Guido said: (a) For some operations, prefix notation just reads better than\npostfix – prefix (and infix!) operations have a long tradition in\nmathematics which likes notations where the visuals help the\nmathematician thinking about a problem. Compare the easy with which we\nrewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of\ndoing the same thing using a raw OO notation.(b) When I read code that says len(x) Iknowthat it is asking for\nthe length of something. This tells me two things: the result is an\ninteger, and the argument is some kind of container. To the contrary,\nwhen I read x.len(), I have to already know that x is some kind of\ncontainer implementing an interface or inheriting from a class that\nhas a standard len(). Witness the confusion we occasionally have when\na class that is not implementing a mapping has a get() or keys()\nmethod, or something that isn’t a file has a write() method.—https://mail.python.org/pipermail/python-3000/2006-November/004643.html (a) For some operations, prefix notation just reads better than\npostfix – prefix (and infix!) operations have a long tradition in\nmathematics which likes notations where the visuals help the\nmathematician thinking about a problem. Compare the easy with which we\nrewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of\ndoing the same thing using a raw OO notation. (b) When I read code that says len(x) Iknowthat it is asking for\nthe length of something. This tells me two things: the result is an\ninteger, and the argument is some kind of container. To the contrary,\nwhen I read x.len(), I have to already know that x is some kind of\ncontainer implementing an interface or inheriting from a class that\nhas a standard len(). Witness the confusion we occasionally have when\na class that is not implementing a mapping has a get() or keys()\nmethod, or something that isn’t a file has a write() method. —https://mail.python.org/pipermail/python-3000/2006-November/004643.html",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why is join() a string method instead of a list or tuple method?¶",
        "answer": "Strings became much more like other standard types starting in Python 1.6, when\nmethods were added which give the same functionality that has always been\navailable using the functions of the string module.  Most of these new methods\nhave been widely accepted, but the one which appears to make some programmers\nfeel uncomfortable is: which gives the result: There are two common arguments against this usage. The first runs along the lines of: “It looks really ugly using a method of a\nstring literal (string constant)”, to which the answer is that it might, but a\nstring literal is just a fixed value. If the methods are to be allowed on names\nbound to strings there is no logical reason to make them unavailable on\nliterals. The second objection is typically cast as: “I am really telling a sequence to\njoin its members together with a string constant”.  Sadly, you aren’t.  For some\nreason there seems to be much less difficulty with havingsplit()as\na string method, since in that case it is easy to see that is an instruction to a string literal to return the substrings delimited by the\ngiven separator (or, by default, arbitrary runs of white space). join()is a string method because in using it you are telling the\nseparator string to iterate over a sequence of strings and insert itself between\nadjacent elements.  This method can be used with any argument which obeys the\nrules for sequence objects, including any new classes you might define yourself.\nSimilar methods exist for bytes and bytearray objects.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "How fast are exceptions?¶",
        "answer": "Atry/exceptblock is extremely efficient if no exceptions\nare raised.  Actually\ncatching an exception is expensive.  In versions of Python prior to 2.0 it was\ncommon to use this idiom: This only made sense when you expected the dict to have the key almost all the\ntime.  If that wasn’t the case, you coded it like this: For this specific case, you could also usevalue=dict.setdefault(key,getvalue(key)), but only if thegetvalue()call is cheap enough because it\nis evaluated in all cases.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why isn’t there a switch or case statement in Python?¶",
        "answer": "In general, structured switch statements execute one block of code\nwhen an expression has a particular value or set of values.\nSince Python 3.10 one can easily match literal values, or constants\nwithin a namespace, with amatch...casestatement.\nAn older alternative is a sequence ofif...elif...elif...else. For cases where you need to choose from a very large number of possibilities,\nyou can create a dictionary mapping case values to functions to call.  For\nexample: For calling methods on objects, you can simplify yet further by using thegetattr()built-in to retrieve methods with a particular name: It’s suggested that you use a prefix for the method names, such asvisit_in\nthis example.  Without such a prefix, if values are coming from an untrusted\nsource, an attacker would be able to call any method on your object. Imitating switch with fallthrough, as with C’s switch-case-default,\nis possible, much harder, and less needed.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?¶",
        "answer": "Answer 1: Unfortunately, the interpreter pushes at least one C stack frame for\neach Python stack frame.  Also, extensions can call back into Python at almost\nrandom moments.  Therefore, a complete threads implementation requires thread\nsupport for C. Answer 2: Fortunately, there isStackless Python,\nwhich has a completely redesigned interpreter loop that avoids the C stack.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why can’t lambda expressions contain statements?¶",
        "answer": "Python lambda expressions cannot contain statements because Python’s syntactic\nframework can’t handle statements nested inside expressions.  However, in\nPython, this is not a serious problem.  Unlike lambda forms in other languages,\nwhere they add functionality, Python lambdas are only a shorthand notation if\nyou’re too lazy to define a function. Functions are already first class objects in Python, and can be declared in a\nlocal scope.  Therefore the only advantage of using a lambda instead of a\nlocally defined function is that you don’t need to invent a name for the\nfunction – but that’s just a local variable to which the function object (which\nis exactly the same type of object that a lambda expression yields) is assigned!",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Can Python be compiled to machine code, C or some other language?¶",
        "answer": "Cythoncompiles a modified version of Python with\noptional annotations into C extensions.Nuitkais\nan up-and-coming compiler of Python into C++ code, aiming to support the full\nPython language.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "How does Python manage memory?¶",
        "answer": "The details of Python memory management depend on the implementation.  The\nstandard implementation of Python,CPython, uses reference counting to\ndetect inaccessible objects, and another mechanism to collect reference cycles,\nperiodically executing a cycle detection algorithm which looks for inaccessible\ncycles and deletes the objects involved. Thegcmodule provides functions\nto perform a garbage collection, obtain debugging statistics, and tune the\ncollector’s parameters. Other implementations (such asJythonorPyPy), however, can rely on a different mechanism\nsuch as a full-blown garbage collector.  This difference can cause some\nsubtle porting problems if your Python code depends on the behavior of the\nreference counting implementation. In some Python implementations, the following code (which is fine in CPython)\nwill probably run out of file descriptors: Indeed, using CPython’s reference counting and destructor scheme, each new\nassignment tofcloses the previous file.  With a traditional GC, however,\nthose file objects will only get collected (and closed) at varying and possibly\nlong intervals. If you want to write code that will work with any Python implementation,\nyou should explicitly close the file or use thewithstatement;\nthis will work regardless of memory management scheme:",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why doesn’t CPython use a more traditional garbage collection scheme?¶",
        "answer": "For one thing, this is not a C standard feature and hence it’s not portable.\n(Yes, we know about the Boehm GC library.  It has bits of assembler code formostcommon platforms, not for all of them, and although it is mostly\ntransparent, it isn’t completely transparent; patches are required to get\nPython to work with it.) Traditional GC also becomes a problem when Python is embedded into other\napplications.  While in a standalone Python it’s fine to replace the standardmalloc()andfree()with versions provided by the GC library, an application\nembedding Python may want to have itsownsubstitute formalloc()andfree(),\nand may not want Python’s.  Right now, CPython works with anything that\nimplementsmalloc()andfree()properly.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why isn’t all memory freed when CPython exits?¶",
        "answer": "Objects referenced from the global namespaces of Python modules are not always\ndeallocated when Python exits.  This may happen if there are circular\nreferences.  There are also certain bits of memory that are allocated by the C\nlibrary that are impossible to free (e.g. a tool like Purify will complain about\nthese).  Python is, however, aggressive about cleaning up memory on exit and\ndoes try to destroy every single object. If you want to force Python to delete certain things on deallocation use theatexitmodule to run a function that will force those deletions.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why are there separate tuple and list data types?¶",
        "answer": "Lists and tuples, while similar in many respects, are generally used in\nfundamentally different ways.  Tuples can be thought of as being similar to\nPascalrecordsor Cstructs; they’re small collections of related data which may\nbe of different types which are operated on as a group.  For example, a\nCartesian coordinate is appropriately represented as a tuple of two or three\nnumbers. Lists, on the other hand, are more like arrays in other languages.  They tend to\nhold a varying number of objects all of which have the same type and which are\noperated on one-by-one.  For example,os.listdir('.')returns a list of\nstrings representing the files in the current directory.  Functions which\noperate on this output would generally not break if you added another file or\ntwo to the directory. Tuples are immutable, meaning that once a tuple has been created, you can’t\nreplace any of its elements with a new value.  Lists are mutable, meaning that\nyou can always change a list’s elements.  Only immutable elements can be used as\ndictionary keys, and hence only tuples and not lists can be used as keys.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "How are lists implemented in CPython?¶",
        "answer": "CPython’s lists are really variable-length arrays, not Lisp-style linked lists.\nThe implementation uses a contiguous array of references to other objects, and\nkeeps a pointer to this array and the array’s length in a list head structure. This makes indexing a lista[i]an operation whose cost is independent of\nthe size of the list or the value of the index. When items are appended or inserted, the array of references is resized.  Some\ncleverness is applied to improve the performance of appending items repeatedly;\nwhen the array must be grown, some extra space is allocated so the next few\ntimes don’t require an actual resize.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "How are dictionaries implemented in CPython?¶",
        "answer": "CPython’s dictionaries are implemented as resizable hash tables.  Compared to\nB-trees, this gives better performance for lookup (the most common operation by\nfar) under most circumstances, and the implementation is simpler. Dictionaries work by computing a hash code for each key stored in the dictionary\nusing thehash()built-in function.  The hash code varies widely depending\non the key and a per-process seed; for example,'Python'could hash to-539294296while'python', a string that differs by a single bit, could hash\nto1142331976.  The hash code is then used to calculate a location in an\ninternal array where the value will be stored.  Assuming that you’re storing\nkeys that all have different hash values, this means that dictionaries take\nconstant time –O(1), in Big-O notation – to retrieve a key.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why must dictionary keys be immutable?¶",
        "answer": "The hash table implementation of dictionaries uses a hash value calculated from\nthe key value to find the key.  If the key were a mutable object, its value\ncould change, and thus its hash could also change.  But since whoever changes\nthe key object can’t tell that it was being used as a dictionary key, it can’t\nmove the entry around in the dictionary.  Then, when you try to look up the same\nobject in the dictionary it won’t be found because its hash value is different.\nIf you tried to look up the old value it wouldn’t be found either, because the\nvalue of the object found in that hash bin would be different. If you want a dictionary indexed with a list, simply convert the list to a tuple\nfirst; the functiontuple(L)creates a tuple with the same entries as the\nlistL.  Tuples are immutable and can therefore be used as dictionary keys. Some unacceptable solutions that have been proposed: Hash lists by their address (object ID).  This doesn’t work because if you\nconstruct a new list with the same value it won’t be found; e.g.: would raise aKeyErrorexception because the id of the[1,2]used in the\nsecond line differs from that in the first line.  In other words, dictionary\nkeys should be compared using==, not usingis. Make a copy when using a list as a key.  This doesn’t work because the list,\nbeing a mutable object, could contain a reference to itself, and then the\ncopying code would run into an infinite loop. Allow lists as keys but tell the user not to modify them.  This would allow a\nclass of hard-to-track bugs in programs when you forgot or modified a list by\naccident. It also invalidates an important invariant of dictionaries: every\nvalue ind.keys()is usable as a key of the dictionary. Mark lists as read-only once they are used as a dictionary key.  The problem\nis that it’s not just the top-level object that could change its value; you\ncould use a tuple containing a list as a key.  Entering anything as a key into\na dictionary would require marking all objects reachable from there as\nread-only – and again, self-referential objects could cause an infinite loop. There is a trick to get around this if you need to, but use it at your own risk:\nYou can wrap a mutable structure inside a class instance which has both a__eq__()and a__hash__()method.\nYou must then make sure that the\nhash value for all such wrapper objects that reside in a dictionary (or other\nhash based structure), remain fixed while the object is in the dictionary (or\nother structure). Note that the hash computation is complicated by the possibility that some\nmembers of the list may be unhashable and also by the possibility of arithmetic\noverflow. Furthermore it must always be the case that ifo1==o2(ieo1.__eq__(o2)isTrue) thenhash(o1)==hash(o2)(ie,o1.__hash__()==o2.__hash__()),\nregardless of whether the object is in a dictionary or not.  If you fail to meet\nthese restrictions dictionaries and other hash based structures will misbehave. In the case ofListWrapper, whenever the wrapper object is in a dictionary the\nwrapped list must not change to avoid anomalies.  Don’t do this unless you are\nprepared to think hard about the requirements and the consequences of not\nmeeting them correctly.  Consider yourself warned.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why doesn’t list.sort() return the sorted list?¶",
        "answer": "In situations where performance matters, making a copy of the list just to sort\nit would be wasteful. Therefore,list.sort()sorts the list in place. In\norder to remind you of that fact, it does not return the sorted list.  This way,\nyou won’t be fooled into accidentally overwriting a list when you need a sorted\ncopy but also need to keep the unsorted version around. If you want to return a new list, use the built-insorted()function\ninstead.  This function creates a new list from a provided iterable, sorts\nit and returns it.  For example, here’s how to iterate over the keys of a\ndictionary in sorted order:",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "How do you specify and enforce an interface spec in Python?¶",
        "answer": "An interface specification for a module as provided by languages such as C++ and\nJava describes the prototypes for the methods and functions of the module.  Many\nfeel that compile-time enforcement of interface specifications helps in the\nconstruction of large programs. Python 2.6 adds anabcmodule that lets you define Abstract Base Classes\n(ABCs).  You can then useisinstance()andissubclass()to check\nwhether an instance or a class implements a particular ABC.  Thecollections.abcmodule defines a set of useful ABCs such asIterable,Container, andMutableMapping. For Python, many of the advantages of interface specifications can be obtained\nby an appropriate test discipline for components. A good test suite for a module can both provide a regression test and serve as a\nmodule interface specification and a set of examples.  Many Python modules can\nbe run as a script to provide a simple “self test.”  Even modules which use\ncomplex external interfaces can often be tested in isolation using trivial\n“stub” emulations of the external interface.  Thedoctestandunittestmodules or third-party test frameworks can be used to construct\nexhaustive test suites that exercise every line of code in a module. An appropriate testing discipline can help build large complex applications in\nPython as well as having interface specifications would.  In fact, it can be\nbetter because an interface specification cannot test certain properties of a\nprogram.  For example, thelist.append()method is expected to add new elements\nto the end of some internal list; an interface specification cannot test that\nyourlist.append()implementation will actually do this correctly, but it’s\ntrivial to check this property in a test suite. Writing test suites is very helpful, and you might want to design your code to\nmake it easily tested. One increasingly popular technique, test-driven\ndevelopment, calls for writing parts of the test suite first, before you write\nany of the actual code.  Of course Python allows you to be sloppy and not write\ntest cases at all.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why is there no goto?¶",
        "answer": "In the 1970s people realized that unrestricted goto could lead\nto messy “spaghetti” code that was hard to understand and revise.\nIn a high-level language, it is also unneeded as long as there\nare ways to branch (in Python, withifstatements andor,and, andif/elseexpressions) and loop (withwhileandforstatements, possibly containingcontinueandbreak). One can also use exceptions to provide a “structured goto”\nthat works even across\nfunction calls.  Many feel that exceptions can conveniently emulate all\nreasonable uses of thegoorgotoconstructs of C, Fortran, and other\nlanguages.  For example: This doesn’t allow you to jump into the middle of a loop, but that’s usually\nconsidered an abuse ofgotoanyway.  Use sparingly.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why can’t raw strings (r-strings) end with a backslash?¶",
        "answer": "More precisely, they can’t end with an odd number of backslashes: the unpaired\nbackslash at the end escapes the closing quote character, leaving an\nunterminated string. Raw strings were designed to ease creating input for processors (chiefly regular\nexpression engines) that want to do their own backslash escape processing. Such\nprocessors consider an unmatched trailing backslash to be an error anyway, so\nraw strings disallow that.  In return, they allow you to pass on the string\nquote character by escaping it with a backslash.  These rules work well when\nr-strings are used for their intended purpose. If you’re trying to build Windows pathnames, note that all Windows system calls\naccept forward slashes too: If you’re trying to build a pathname for a DOS command, try e.g. one of",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why doesn’t Python have a “with” statement for attribute assignments?¶",
        "answer": "Python has awithstatement that wraps the execution of a block, calling code\non the entrance and exit from the block.  Some languages have a construct that\nlooks like this: In Python, such a construct would be ambiguous. Other languages, such as Object Pascal, Delphi, and C++, use static types, so\nit’s possible to know, in an unambiguous way, what member is being assigned\nto. This is the main point of static typing – the compileralwaysknows the\nscope of every variable at compile time. Python uses dynamic types. It is impossible to know in advance which attribute\nwill be referenced at runtime. Member attributes may be added or removed from\nobjects on the fly. This makes it impossible to know, from a simple reading,\nwhat attribute is being referenced: a local one, a global one, or a member\nattribute? For instance, take the following incomplete snippet: The snippet assumes thatamust have a member attribute calledx. However,\nthere is nothing in Python that tells the interpreter this. What should happen\nifais, let us say, an integer?  If there is a global variable namedx,\nwill it be used inside thewithblock?  As you see, the dynamic nature of Python\nmakes such choices much harder. The primary benefit ofwithand similar language features (reduction of code\nvolume) can, however, easily be achieved in Python by assignment.  Instead of: write this: This also has the side-effect of increasing execution speed because name\nbindings are resolved at run-time in Python, and the second version only needs\nto perform the resolution once. Similar proposals that would introduce syntax to further reduce code volume,\nsuch as using a ‘leading dot’, have been rejected in favour of explicitness (seehttps://mail.python.org/pipermail/python-ideas/2016-May/040070.html).",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why don’t generators support the with statement?¶",
        "answer": "For technical reasons, a generator used directly as a context manager\nwould not work correctly.  When, as is most common, a generator is used as\nan iterator run to completion, no closing is needed.  When it is, wrap\nit ascontextlib.closing(generator)in thewithstatement.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why are colons required for the if/while/def/class statements?¶",
        "answer": "The colon is required primarily to enhance readability (one of the results of\nthe experimental ABC language).  Consider this: versus Notice how the second one is slightly easier to read.  Notice further how a\ncolon sets off the example in this FAQ answer; it’s a standard usage in English. Another minor reason is that the colon makes it easier for editors with syntax\nhighlighting; they can look for colons to decide when indentation needs to be\nincreased instead of having to do a more elaborate parsing of the program text.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Why does Python allow commas at the end of lists and tuples?¶",
        "answer": "Python lets you add a trailing comma at the end of lists, tuples, and\ndictionaries: There are several reasons to allow this. When you have a literal value for a list, tuple, or dictionary spread across\nmultiple lines, it’s easier to add more elements because you don’t have to\nremember to add a comma to the previous line.  The lines can also be reordered\nwithout creating a syntax error. Accidentally omitting the comma can lead to errors that are hard to diagnose.\nFor example: This list looks like it has four elements, but it actually contains three:\n“fee”, “fiefoo” and “fum”.  Always adding the comma avoids this source of error. Allowing the trailing comma may also make programmatic code generation easier.",
        "source": "data/html/design-history-faq.html"
    },
    {
        "question": "Can I create my own functions in C?¶",
        "answer": "Contents Extending/Embedding FAQ Can I create my own functions in C? Can I create my own functions in C++? Writing C is hard; are there any alternatives? How can I execute arbitrary Python statements from C? How can I evaluate an arbitrary Python expression from C? How do I extract C values from a Python object? How do I use Py_BuildValue() to create a tuple of arbitrary length? How do I call an object’s method from C? How do I catch the output from PyErr_Print() (or anything that prints to stdout/stderr)? How do I access a module written in Python from C? How do I interface to C++ objects from Python? I added a module using the Setup file and the make fails; why? How do I debug an extension? I want to compile a Python module on my Linux system, but some files are missing. Why? How do I tell “incomplete input” from “invalid input”? How do I find undefined g++ symbols __builtin_new or __pure_virtual? Can I create an object class with some methods implemented in C and others in Python (e.g. through inheritance)? Yes, you can create built-in modules containing functions, variables, exceptions\nand even new types in C.  This is explained in the documentExtending and Embedding the Python Interpreter. Most intermediate or advanced Python books will also cover this topic. Yes, using the C compatibility features found in C++.  Placeextern\"C\"{...}around the Python include files and putextern\"C\"before each\nfunction that is going to be called by the Python interpreter.  Global or static\nC++ objects with constructors are probably not a good idea. There are a number of alternatives to writing your own C extensions, depending\non what you’re trying to do. Cythonand its relativePyrexare compilers\nthat accept a slightly modified form of Python and generate the corresponding\nC code.  Cython and Pyrex make it possible to write an extension without having\nto learn Python’s C API. If you need to interface to some C or C++ library for which no Python extension\ncurrently exists, you can try wrapping the library’s data types and functions\nwith a tool such asSWIG.SIP,CXXBoost, orWeaveare also\nalternatives for wrapping C++ libraries. The highest-level function to do this isPyRun_SimpleString()which takes\na single string argument to be executed in the context of the module__main__and returns0for success and-1when an exception occurred\n(includingSyntaxError).  If you want more control, usePyRun_String(); see the source forPyRun_SimpleString()inPython/pythonrun.c. Call the functionPyRun_String()from the previous question with the\nstart symbolPy_eval_input; it parses an expression, evaluates it and\nreturns its value. That depends on the object’s type.  If it’s a tuple,PyTuple_Size()returns its length andPyTuple_GetItem()returns the item at a specified\nindex.  Lists have similar functions,PyList_Size()andPyList_GetItem(). For bytes,PyBytes_Size()returns its length andPyBytes_AsStringAndSize()provides a pointer to its value and its\nlength.  Note that Python bytes objects may contain null bytes so C’sstrlen()should not be used. To test the type of an object, first make sure it isn’tNULL, and then usePyBytes_Check(),PyTuple_Check(),PyList_Check(), etc. There is also a high-level API to Python objects which is provided by the\nso-called ‘abstract’ interface – readInclude/abstract.hfor further\ndetails.  It allows interfacing with any kind of Python sequence using calls\nlikePySequence_Length(),PySequence_GetItem(), etc. as well\nas many other useful protocols such as numbers (PyNumber_Index()et\nal.) and mappings in the PyMapping APIs. You can’t.  UsePyTuple_Pack()instead. ThePyObject_CallMethod()function can be used to call an arbitrary\nmethod of an object.  The parameters are the object, the name of the method to\ncall, a format string like that used withPy_BuildValue(), and the\nargument values: This works for any object that has methods – whether built-in or user-defined.\nYou are responsible for eventuallyPy_DECREF()‘ing the return value. To call, e.g., a file object’s “seek” method with arguments 10, 0 (assuming the\nfile object pointer is “f”): Note that sincePyObject_CallObject()alwayswants a tuple for the\nargument list, to call a function without arguments, pass “()” for the format,\nand to call a function with one argument, surround the argument in parentheses,\ne.g. “(i)”. In Python code, define an object that supports thewrite()method.  Assign\nthis object tosys.stdoutandsys.stderr.  Call print_error, or\njust allow the standard traceback mechanism to work. Then, the output will go\nwherever yourwrite()method sends it. The easiest way to do this is to use theio.StringIOclass: A custom object to do the same would look like this: You can get a pointer to the module object as follows: If the module hasn’t been imported yet (i.e. it is not yet present insys.modules), this initializes the module; otherwise it simply returns\nthe value ofsys.modules[\"<modulename>\"].  Note that it doesn’t enter the\nmodule into any namespace – it only ensures it has been initialized and is\nstored insys.modules. You can then access the module’s attributes (i.e. any name defined in the\nmodule) as follows: CallingPyObject_SetAttrString()to assign to variables in the module\nalso works. Depending on your requirements, there are many approaches.  To do this manually,\nbegin by readingthe “Extending and Embedding” document.  Realize that for the Python run-time system, there isn’t a\nwhole lot of difference between C and C++ – so the strategy of building a new\nPython type around a C structure (pointer) type will also work for C++ objects. For C++ libraries, seeWriting C is hard; are there any alternatives?. Setup must end in a newline, if there is no newline there, the build process\nfails.  (Fixing this requires some ugly shell script hackery, and this bug is so\nminor that it doesn’t seem worth the effort.) When using GDB with dynamically loaded extensions, you can’t set a breakpoint in\nyour extension until your extension is loaded. In your.gdbinitfile (or interactively), add the command: Then, when you run GDB: Most packaged versions of Python don’t include the/usr/lib/python2.x/config/directory, which contains various files\nrequired for compiling Python extensions. For Red Hat, install the python-devel RPM to get the necessary files. For Debian, runapt-getinstallpython-dev. Sometimes you want to emulate the Python interactive interpreter’s behavior,\nwhere it gives you a continuation prompt when the input is incomplete (e.g. you\ntyped the start of an “if” statement or you didn’t close your parentheses or\ntriple string quotes), but it gives you a syntax error message immediately when\nthe input is invalid. In Python you can use thecodeopmodule, which approximates the parser’s\nbehavior sufficiently.  IDLE uses this, for example. The easiest way to do it in C is to callPyRun_InteractiveLoop()(perhaps\nin a separate thread) and let the Python interpreter handle the input for\nyou. You can also set thePyOS_ReadlineFunctionPointer()to point at your\ncustom input function. SeeModules/readline.candParser/myreadline.cfor more hints. To dynamically load g++ extension modules, you must recompile Python, relink it\nusing g++ (change LINKCC in the Python Modules Makefile), and link your\nextension module using g++ (e.g.,g++-shared-omymodule.somymodule.o). Yes, you can inherit from built-in classes such asint,list,dict, etc. The Boost Python Library (BPL,https://www.boost.org/libs/python/doc/index.html)\nprovides a way of doing this from C++ (i.e. you can inherit from an extension\nclass written in C++ using the BPL).",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "Can I create my own functions in C?¶",
        "answer": "Yes, you can create built-in modules containing functions, variables, exceptions\nand even new types in C.  This is explained in the documentExtending and Embedding the Python Interpreter. Most intermediate or advanced Python books will also cover this topic.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "Can I create my own functions in C++?¶",
        "answer": "Yes, using the C compatibility features found in C++.  Placeextern\"C\"{...}around the Python include files and putextern\"C\"before each\nfunction that is going to be called by the Python interpreter.  Global or static\nC++ objects with constructors are probably not a good idea.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "Writing C is hard; are there any alternatives?¶",
        "answer": "There are a number of alternatives to writing your own C extensions, depending\non what you’re trying to do. Cythonand its relativePyrexare compilers\nthat accept a slightly modified form of Python and generate the corresponding\nC code.  Cython and Pyrex make it possible to write an extension without having\nto learn Python’s C API. If you need to interface to some C or C++ library for which no Python extension\ncurrently exists, you can try wrapping the library’s data types and functions\nwith a tool such asSWIG.SIP,CXXBoost, orWeaveare also\nalternatives for wrapping C++ libraries.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How can I execute arbitrary Python statements from C?¶",
        "answer": "The highest-level function to do this isPyRun_SimpleString()which takes\na single string argument to be executed in the context of the module__main__and returns0for success and-1when an exception occurred\n(includingSyntaxError).  If you want more control, usePyRun_String(); see the source forPyRun_SimpleString()inPython/pythonrun.c.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How can I evaluate an arbitrary Python expression from C?¶",
        "answer": "Call the functionPyRun_String()from the previous question with the\nstart symbolPy_eval_input; it parses an expression, evaluates it and\nreturns its value.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I extract C values from a Python object?¶",
        "answer": "That depends on the object’s type.  If it’s a tuple,PyTuple_Size()returns its length andPyTuple_GetItem()returns the item at a specified\nindex.  Lists have similar functions,PyList_Size()andPyList_GetItem(). For bytes,PyBytes_Size()returns its length andPyBytes_AsStringAndSize()provides a pointer to its value and its\nlength.  Note that Python bytes objects may contain null bytes so C’sstrlen()should not be used. To test the type of an object, first make sure it isn’tNULL, and then usePyBytes_Check(),PyTuple_Check(),PyList_Check(), etc. There is also a high-level API to Python objects which is provided by the\nso-called ‘abstract’ interface – readInclude/abstract.hfor further\ndetails.  It allows interfacing with any kind of Python sequence using calls\nlikePySequence_Length(),PySequence_GetItem(), etc. as well\nas many other useful protocols such as numbers (PyNumber_Index()et\nal.) and mappings in the PyMapping APIs.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I use Py_BuildValue() to create a tuple of arbitrary length?¶",
        "answer": "You can’t.  UsePyTuple_Pack()instead.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I call an object’s method from C?¶",
        "answer": "ThePyObject_CallMethod()function can be used to call an arbitrary\nmethod of an object.  The parameters are the object, the name of the method to\ncall, a format string like that used withPy_BuildValue(), and the\nargument values: This works for any object that has methods – whether built-in or user-defined.\nYou are responsible for eventuallyPy_DECREF()‘ing the return value. To call, e.g., a file object’s “seek” method with arguments 10, 0 (assuming the\nfile object pointer is “f”): Note that sincePyObject_CallObject()alwayswants a tuple for the\nargument list, to call a function without arguments, pass “()” for the format,\nand to call a function with one argument, surround the argument in parentheses,\ne.g. “(i)”.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I catch the output from PyErr_Print() (or anything that prints to stdout/stderr)?¶",
        "answer": "In Python code, define an object that supports thewrite()method.  Assign\nthis object tosys.stdoutandsys.stderr.  Call print_error, or\njust allow the standard traceback mechanism to work. Then, the output will go\nwherever yourwrite()method sends it. The easiest way to do this is to use theio.StringIOclass: A custom object to do the same would look like this:",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I access a module written in Python from C?¶",
        "answer": "You can get a pointer to the module object as follows: If the module hasn’t been imported yet (i.e. it is not yet present insys.modules), this initializes the module; otherwise it simply returns\nthe value ofsys.modules[\"<modulename>\"].  Note that it doesn’t enter the\nmodule into any namespace – it only ensures it has been initialized and is\nstored insys.modules. You can then access the module’s attributes (i.e. any name defined in the\nmodule) as follows: CallingPyObject_SetAttrString()to assign to variables in the module\nalso works.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I interface to C++ objects from Python?¶",
        "answer": "Depending on your requirements, there are many approaches.  To do this manually,\nbegin by readingthe “Extending and Embedding” document.  Realize that for the Python run-time system, there isn’t a\nwhole lot of difference between C and C++ – so the strategy of building a new\nPython type around a C structure (pointer) type will also work for C++ objects. For C++ libraries, seeWriting C is hard; are there any alternatives?.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "I added a module using the Setup file and the make fails; why?¶",
        "answer": "Setup must end in a newline, if there is no newline there, the build process\nfails.  (Fixing this requires some ugly shell script hackery, and this bug is so\nminor that it doesn’t seem worth the effort.)",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I debug an extension?¶",
        "answer": "When using GDB with dynamically loaded extensions, you can’t set a breakpoint in\nyour extension until your extension is loaded. In your.gdbinitfile (or interactively), add the command: Then, when you run GDB:",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "I want to compile a Python module on my Linux system, but some files are missing. Why?¶",
        "answer": "Most packaged versions of Python don’t include the/usr/lib/python2.x/config/directory, which contains various files\nrequired for compiling Python extensions. For Red Hat, install the python-devel RPM to get the necessary files. For Debian, runapt-getinstallpython-dev.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I tell “incomplete input” from “invalid input”?¶",
        "answer": "Sometimes you want to emulate the Python interactive interpreter’s behavior,\nwhere it gives you a continuation prompt when the input is incomplete (e.g. you\ntyped the start of an “if” statement or you didn’t close your parentheses or\ntriple string quotes), but it gives you a syntax error message immediately when\nthe input is invalid. In Python you can use thecodeopmodule, which approximates the parser’s\nbehavior sufficiently.  IDLE uses this, for example. The easiest way to do it in C is to callPyRun_InteractiveLoop()(perhaps\nin a separate thread) and let the Python interpreter handle the input for\nyou. You can also set thePyOS_ReadlineFunctionPointer()to point at your\ncustom input function. SeeModules/readline.candParser/myreadline.cfor more hints.",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "How do I find undefined g++ symbols __builtin_new or __pure_virtual?¶",
        "answer": "To dynamically load g++ extension modules, you must recompile Python, relink it\nusing g++ (change LINKCC in the Python Modules Makefile), and link your\nextension module using g++ (e.g.,g++-shared-omymodule.somymodule.o).",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "Can I create an object class with some methods implemented in C and others in Python (e.g. through inheritance)?¶",
        "answer": "Yes, you can inherit from built-in classes such asint,list,dict, etc. The Boost Python Library (BPL,https://www.boost.org/libs/python/doc/index.html)\nprovides a way of doing this from C++ (i.e. you can inherit from an extension\nclass written in C++ using the BPL).",
        "source": "data/html/extending-embedding-faq.html"
    },
    {
        "question": "General GUI Questions¶",
        "answer": "Contents Graphic User Interface FAQ General GUI Questions What GUI toolkits exist for Python? Tkinter questions How do I freeze Tkinter applications? Can I have Tk events handled while waiting for I/O? I can’t get key bindings to work in Tkinter: why? Standard builds of Python include an object-oriented interface to the Tcl/Tk\nwidget set, calledtkinter.  This is probably the easiest to\ninstall (since it comes included with mostbinary distributionsof Python) and use.\nFor more info about Tk, including pointers to the source, see theTcl/Tk home page.  Tcl/Tk is fully portable to the\nmacOS, Windows, and Unix platforms. Depending on what platform(s) you are aiming at, there are also several\nalternatives. Alist of cross-platformandplatform-specificGUI\nframeworks can be found on the python wiki. Freeze is a tool to create stand-alone applications.  When freezing Tkinter\napplications, the applications will not be truly stand-alone, as the application\nwill still need the Tcl and Tk libraries. One solution is to ship the application with the Tcl and Tk libraries, and point\nto them at run-time using theTCL_LIBRARYandTK_LIBRARYenvironment variables. To get truly stand-alone applications, the Tcl scripts that form the library\nhave to be integrated into the application as well. One tool supporting that is\nSAM (stand-alone modules), which is part of the Tix distribution\n(https://tix.sourceforge.net/). Build Tix with SAM enabled, perform the appropriate call toTclsam_init(), etc. inside Python’sModules/tkappinit.c, and link with libtclsam and libtksam (you\nmight include the Tix libraries as well). On platforms other than Windows, yes, and you don’t even\nneed threads!  But you’ll have to restructure your I/O\ncode a bit.  Tk has the equivalent of Xt’sXtAddInput()call, which allows you\nto register a callback function which will be called from the Tk mainloop when\nI/O is possible on a file descriptor.  SeeFile Handlers. An often-heard complaint is that event handlersboundto events with thebind()method\ndon’t get handled even when the appropriate key is pressed. The most common cause is that the widget to which the binding applies doesn’t\nhave “keyboard focus”.  Check out the Tk documentation for the focus command.\nUsually a widget is given the keyboard focus by clicking in it (but not for\nlabels; see the takefocus option).",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "General GUI Questions¶",
        "answer": "",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "What GUI toolkits exist for Python?¶",
        "answer": "Standard builds of Python include an object-oriented interface to the Tcl/Tk\nwidget set, calledtkinter.  This is probably the easiest to\ninstall (since it comes included with mostbinary distributionsof Python) and use.\nFor more info about Tk, including pointers to the source, see theTcl/Tk home page.  Tcl/Tk is fully portable to the\nmacOS, Windows, and Unix platforms. Depending on what platform(s) you are aiming at, there are also several\nalternatives. Alist of cross-platformandplatform-specificGUI\nframeworks can be found on the python wiki.",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "Tkinter questions¶",
        "answer": "Freeze is a tool to create stand-alone applications.  When freezing Tkinter\napplications, the applications will not be truly stand-alone, as the application\nwill still need the Tcl and Tk libraries. One solution is to ship the application with the Tcl and Tk libraries, and point\nto them at run-time using theTCL_LIBRARYandTK_LIBRARYenvironment variables. To get truly stand-alone applications, the Tcl scripts that form the library\nhave to be integrated into the application as well. One tool supporting that is\nSAM (stand-alone modules), which is part of the Tix distribution\n(https://tix.sourceforge.net/). Build Tix with SAM enabled, perform the appropriate call toTclsam_init(), etc. inside Python’sModules/tkappinit.c, and link with libtclsam and libtksam (you\nmight include the Tix libraries as well). On platforms other than Windows, yes, and you don’t even\nneed threads!  But you’ll have to restructure your I/O\ncode a bit.  Tk has the equivalent of Xt’sXtAddInput()call, which allows you\nto register a callback function which will be called from the Tk mainloop when\nI/O is possible on a file descriptor.  SeeFile Handlers. An often-heard complaint is that event handlersboundto events with thebind()method\ndon’t get handled even when the appropriate key is pressed. The most common cause is that the widget to which the binding applies doesn’t\nhave “keyboard focus”.  Check out the Tk documentation for the focus command.\nUsually a widget is given the keyboard focus by clicking in it (but not for\nlabels; see the takefocus option).",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "How do I freeze Tkinter applications?¶",
        "answer": "Freeze is a tool to create stand-alone applications.  When freezing Tkinter\napplications, the applications will not be truly stand-alone, as the application\nwill still need the Tcl and Tk libraries. One solution is to ship the application with the Tcl and Tk libraries, and point\nto them at run-time using theTCL_LIBRARYandTK_LIBRARYenvironment variables. To get truly stand-alone applications, the Tcl scripts that form the library\nhave to be integrated into the application as well. One tool supporting that is\nSAM (stand-alone modules), which is part of the Tix distribution\n(https://tix.sourceforge.net/). Build Tix with SAM enabled, perform the appropriate call toTclsam_init(), etc. inside Python’sModules/tkappinit.c, and link with libtclsam and libtksam (you\nmight include the Tix libraries as well).",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "Can I have Tk events handled while waiting for I/O?¶",
        "answer": "On platforms other than Windows, yes, and you don’t even\nneed threads!  But you’ll have to restructure your I/O\ncode a bit.  Tk has the equivalent of Xt’sXtAddInput()call, which allows you\nto register a callback function which will be called from the Tk mainloop when\nI/O is possible on a file descriptor.  SeeFile Handlers.",
        "source": "data/html/gui-faq.html"
    },
    {
        "question": "I can’t get key bindings to work in Tkinter: why?¶",
        "answer": "An often-heard complaint is that event handlersboundto events with thebind()method\ndon’t get handled even when the appropriate key is pressed. The most common cause is that the widget to which the binding applies doesn’t\nhave “keyboard focus”.  Check out the Tk documentation for the focus command.\nUsually a widget is given the keyboard focus by clicking in it (but not for\nlabels; see the takefocus option).",
        "source": "data/html/gui-faq.html"
    }
]